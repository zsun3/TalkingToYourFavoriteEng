[
    {
        "44987": [
            "Is this needed?",
            "Do we need to keep this, at what point can we remove if so? "
        ]
    },
    {
        "44914": [
            "Love this setup by the way",
            "We should externalize some of these test payloads, so we can reuse and avoid these large diffs",
            "I'll raise a change today with what I'm thinking. It's worked superbly well for valgen thus far",
            "I personally don't love this naming. Not only are they hard to tell the difference in the order of (when someone inevitably has to solve for a test broken due to it), they don't communicate much about the content, nor what boundaries the different instances represent.\r\n\r\nI think it makes using them much more challenging, as we can't reason about them without jumping into the content itself",
            "Should this be `NoComponentsError`?\r\n\r\n```suggestion\r\n    is SduiBuilderError.BuildError.NoComponentsError -> EnricherError.BuilderError.NoComponentsError\r\n```",
            "If we left this [code](https://github.aexp.com/amex-eng/m1-msl/pull/44914/files#r3569864) as is, we'd never hit this debug.\r\n\r\nMaybe a point to potentially improve, we should link these enums with the messages explicitly. The data objects can have some generic top-level field which is their `baseMessage` which they serve via some `message` (default implementation is just the `baseMessage`)\r\n\r\n\r\n```kotlin\r\nsealed class SduiError(val baseMessage: NotBlankString) {\r\n    val message: NotBlankString\r\n        get() = baseMessage\r\n}\r\n```",
            "This is personally what I used in ValGen, I thought it worked really nicely.\r\n\r\n[Here's the overview from a composite message with components](https://github.aexp.com/amex-eng/m1-msl/blob/bcba9e171b44c838959315b233aa1baddd6c642b/backend-service-clients/messaging-v2-service-client/chat-service-client/src/testFixtures/java/com/americanexpress/mobileone/bsc/chat/conversation/client/conversation/messages/FakeClientCompositeMessage.kt#L43-L85)\r\n\r\n[And here's the shared values we used to intentionally set aside \"known, fixed, non-boundary values\" for consistent usage without the overhead of changing in multiple places.](https://github.aexp.com/amex-eng/m1-msl/blob/bcba9e171b44c838959315b233aa1baddd6c642b/backend-service-clients/messaging-v2-service-client/chat-service-client/src/testFixtures/java/com/americanexpress/mobileone/bsc/chat/conversation/client/conversation/FakeClientCommonValues.kt#L38-L176)",
            "Can understand that for sure",
            "I agrue we shouldn't depend at all on any non-functional boundaries, to be clear. Unique text doesn't affect a test, thus we should ideally not care about it (except for cases where it would affect the test of course). Ultimately just a focus on testing boundaries intentionally"
        ]
    },
    {
        "44876": [
            "The only external facing change that occured",
            "No more potential issues due to error leaking",
            "Tight bound from type-safety guarantees ",
            "Build is failing but I have to leave, I think it does a good job highlighting the point though.\r\n\r\nLet me know if you have any questions @zsun3",
            "This can be unit tested to guarantee there's no impact, I don't see what risk there could be. Something existing is not a reason why we ought to keep it, else we will quickly snowball to unmanageable. \r\n\r\nThis is a no-op change, it doesn't break anything and can be assertably proven for all inputs to yield identical outputs. In doing so, we prove, via induction, that there's guaranteed to be no impact.\r\n\r\nPlease tell me if I'm missing anything, I'm not trying to be a blocker, but also, this is a very feasible win with some super meaningful upside and reduction in risk. "
        ]
    },
    {
        "44821": [
            "Currently we rely on the assumption that if defined, the entire set of `enum.entries`  is case insensitive, which lets us use a factory to avoid registering for every `enum`, and can even allow us to register the factory globally and pick up the `@CaseInsensitve` annotations on types via introspection a single time. \r\n\r\nElse we will have to do dynamically, which is a non-trivial cost, and usage is much more fragile at that point. \r\n\r\nIt's doable, but I don't see a reason you'd only want a single field to be case-insenstive, at least not for how much it'd cost us in terms of perf and DX.",
            "No, we check the class definition to be `isEnum` in the factory resolution\r\n\r\n```kotlin\r\nobject CaseInsensitiveEnumJsonAdapterFactory : JsonAdapter.Factory {\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    override fun create(\r\n        type: Type,\r\n        annotations: MutableSet<out Annotation>,\r\n        moshi: Moshi\r\n    ): JsonAdapter<*>? = takeIf { type.rawType.isEnum && type.rawType.isAnnotationPresent(CaseInsensitive::class.java) }\r\n        ?.let { CaseInsensitiveEnumJsonAdapter(type.rawType as Class<out Enum<*>>) }\r\n        ....\r\n}\r\n```",
            "Note, we can't enforce the annotation is only on `enum` classes as the JVM can't truly tell them apart technically (it can, but not in the IR form, which is key)",
            "Great to hear this was a nice way to get visibility, going to be doing something similar for another one, hopefully can arm the team with some pretty nice solutions. Long term goal is getting us on a more \"type-driven development\" path long-term"
        ]
    },
    {
        "44816": [
            "What do we do in this scenario? To me, this is almost always an approach that we shouldn't take, unless we are seeking to be resilient to arbitrary values being received here.\r\n\r\nThis will catch everything, meaning we can no longer meaningfully fail to deserialize this enum, functionally making it identical to a string. This gives us all the issues of strings, with the added cost of the perception of type-safety (via deception...).\r\n\r\nReally think we should avoid this, pretty strong view. In general, unless there's defined behavior we're expecting, and this is a meaningful category, this is functionally an \"intentional bug\" in my view.",
            "Here, `null` and `asd;flkjg;lkjasf` will be treated identically, is that the intention? `active` will also be treated the same, as it will fallback. This is the risk of fallback, to be clear, we've turned this enum class, which presumably has a domain less than the set of all strings, into a regular string. This isn't unique to this pull request, but is a concern IMO MSL wide"
        ]
    },
    {
        "44695": [
            "Moved up for reuse by external button",
            "Reoprganized a bit",
            "\r\nLinted requires use-site annotations in Kotlin 2.1+ (only going to write this comment a single time to not spam)",
            "We aren't actually sent this I don't think but it was unclear to me, went with flexible approach for the interim",
            "Lol funny you said, but yes, it fails linting now due to version uplift for Kotlin",
            "[Link to comment where I outlined this in anticipation](https://github.aexp.com/amex-eng/m1-msl/pull/44695#discussion_r3557584)",
            "This implementation is how the `Enumerated<T>` is designed to be used, tiny refactor as I had to change anyways",
            "I was avoiding potentially invalid setups in test data was the thinking.\r\n\r\nOverall I don't like this approach as a whole, to be clear",
            "There's no `NOT_SUPPORTED` given by backend, we are interpolating this based on `type` + `stlye` logic\r\n\r\n[Code in question](https://github.aexp.com/amex-eng/m1-msl/blob/62c1ac20a2ac6160ffe36a62d29936b3296664c9/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/mappers/composite/CompositeMessageMapper.kt#L294-L301)",
            "Ditto [this](https://github.aexp.com/amex-eng/m1-msl/pull/44695#discussion_r3557623), if we changed to this we'd have deserialization exceptions",
            "Shoot this is on me, the payload I sent had this included\r\n",
            "Updated this test, we should fail in this scenario. See the [backend contract](https://github.aexp.com/pages/amex-eng/askamex-swagger-mobile/) for reference as to data expectations\r\n\r\n<img width=\"1261\" alt=\"image\" src=\"https://github.aexp.com/amex-eng/m1-msl/assets/17603/105201f4-a092-494e-892e-86fea568a8be\">\r\n",
            "Resovled",
            "This isn't backend, this is for clients, which as discussed are not expecting a value here. I default to simplify instantatnion in test data",
            "I'm unsure what you mean, are you saying I should add static imports?\r\n\r\nPersonally I think this is much more clear given the similarity of naming",
            "Ah, the choice here was intentional, interesting that you prefer, is it just line length? I'm only asking to try and undertsand the perspective a bit, it's not mine currently but I'm also not closed off to my current approach having flaws.\r\n\r\nThere's a lot of complex type mapping happening in this file, hence the focus on clarity above all, though it definitely does make it a bit verbose. I wish IntelliJ still had the intention for `add type alias` because if it was a smoother workflow I'd certainly use it here and solve for brevity and clarity.",
            "This is actually a great point, updating"
        ]
    },
    {
        "44617": [
            "Can we name this event, ie. this could be:\r\n\r\n```suggestion\r\n    fun emitFollowUpBenefitsEvent(): SseProcess\r\n```\r\n\r\nSorry just unclear as a first-time reader what \"event\" means.\r\n\r\nAlso, we're starting a new `SseProcess` here, are we going to be reusing this I assume? If so something like the below may be better\r\n\r\n```suggestion\r\n    fun followUpBenefits(): SseProcess\r\n```",
            "I'd request the changes here honestly, it's small, this is net new, and solutions start in pull requests like these :) Sorry, don't want to be too stiff, but this is an easy win :)",
            "[2 minute rule](https://reclaim.ai/blog/2-minute-rule) is my rule of thumb personally",
            "Approved! Thanks, sorry just trying a new approach on these to try and help the team, hopefully didn't come off poorly!"
        ]
    },
    {
        "44465": [
            "Nit:\r\nPersonally I think I'd make this parameter a receiver, ie:\r\n\r\n```kotlin\r\n        private fun NonEmptyList<AvailableOffer.Card>.normalizeNonEmptyOffers()-....\r\n```",
            "Really like this scope management here personally, traversing the scope via `with(...) {}` keeps the promiximity of relevant attributes really close",
            "Whenever anyone asks the reason for my crusade of \"type-driven development\", this will be a link I send. This entire segment of code, while sensible in this setting, is totally unneeded, and I think very anti-patterny personally. \r\n\r\nWith sufficiently tight type boundaries we could avoid this altogether, and via a value class with some enforced initializer, we could tighten the boundaries to fit any variety of conditions as the needs arise.",
            "I mean this is the best way @jtorr64 , to be clear. Given the constraints I think I'd do something similar, but also accepting the constraints is not something I'm good at :) ",
            "At this point we're fully decoupled from any and all backends as far as our type-safety is concerned, we definitely don't have to care about the data source or it's constraints. We instead must only depend on the exposed constraints defined by `Client` models. \r\n\r\nIf the `Client` guarantees to us, that somehow someway, we will get an `enum` , and that `NONE` is in there, and it will enforce these, we stop having to be concerned with the BSC this far from the actual HTTP call. If we don't,  we have to keep the entire system in our mind, the whole time we write code",
            "I'd posit it's not whether they're fine with it, but whether it's nullable. \r\n\r\nSomething being an amalgamation of two types in a shared hierarchy isn't a \"solution\" in my view. These are seperable or they aren't, and the fields are present, optional, or excluded, but all of this is purely bound to the info being communicated, not a preference. \r\n\r\nI know it sounds absoluteist, but it does make clear the responsibility. Ultimately, how clients implement is up to them, they can ignore type discriminators if they want, heck they can parse it as a string blob. None of that changes the \"why\" for us. The process of explicit discrimination gives us compile-time guarantee, and erases a ton of possible issues, that our data looks a certain way. If we know \"in all happy scenarios it will look like this\" we gain nothing at MSL from weakening it, even if clients won't use it. These things allow us to avoid the invasion of conditionals, the fragility of tests checking nulls, and the need to have a test in the first place.",
            "Discussed comments, all of mine are okay to be merged as is, ongoing effort but very much not meant for scope of these changes! "
        ]
    },
    {
        "44269": [
            "~~This is concerning, and should be resolved prior to merge, at least for all new additions~~\r\n\r\n~~We should not have multiple top-level (not nested) classes, of any types, defined in a single file. This is pretty explicitly declared in the [official Kotlin Coding Convention](https://kotlinlang.org/docs/coding-conventions.html#source-file-names)~~\r\n\r\nI was wrong here, thanks @czschwar for checking me on this",
            "Also, acronyms are something we should avoid, and should be seen as a bad practice in general. \r\n\r\nThis is because honestly, I don't know what `Lxp` means, and I don't know where to look, or who to ask (not that those are valid solutions, but I'm trying to highlight how hard it can be from a reviewers perspective)",
            "We should be using [`JsonWebToken`](https://github.aexp.com/amex-eng/m1-msl/blob/ec632576b645969d5470db5edee4cb8184b35cfe/common/msl-common/src/main/java/com/americanexpress/intlmobl/app/clientrequest/common/JsonWebToken.kt#L7) for these, we have a type-safe representation, we should prefer that over a plain string",
            "There's a type identifier in here, surely we can discriminate? This really is scary long-term as I don't believe these fields are truly supported as defined by the model.\r\n\r\nThat is, I could using this constructor, create an invalid representation of data. If you want to discuss how to handle this and solve for it I'm more than happy to do so, please feel free to reach out and we can discuss!\r\n\r\nA couple of references for a set of hierarchies I've worked to illuminate and for which the outcomes have been dramatically improved:\r\n* [ApiMessage](https://github.aexp.com/amex-eng/m1-msl/blob/337437234f119407265f3ee8d657a6e5f5557731/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/models/api/message/ApiMessage.kt#L14-L64)\r\n* [ApiConversationResponse](https://github.aexp.com/amex-eng/m1-msl/blob/0ad74e98db7f19b7a080fbdc5da82cd8f407ed49/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/models/api/ApiConversationResponse.kt#L15)\r\n  * Prior this was a [Passthrough map](https://github.aexp.com/amex-eng/m1-msl/blob/b7fcc4042838c9aaf6bd4b21ab390a813c4203c1/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/ConversationApiModel.kt#L131-L137), just to be clear",
            "Surely these two at least are not nullable I'd hope. If they are I think they warrant a discussion about the minimum we can accept from backends.\r\n\r\nUltimately, your data class states that we can accept an object `{ }`, which is a equally valid, and identical type of room, to a fully non-null representation. That concerns me to be candid",
            "[Should be in it's own file per coding conventions](https://kotlinlang.org/docs/coding-conventions.html#source-file-names)",
            "Should be in its own file according to [Kotlin Coding Conventions](https://kotlinlang.org/docs/coding-conventions.html#source-file-names)",
            "Comments aren't type safe, and can fall out of sync with code, we shouldn't include them as we can't trust them to accurate",
            "Should be in its own file according to [Kotlin Coding Conventions](https://kotlinlang.org/docs/coding-conventions.html#source-file-names)",
            "Should be in its own file according to [Kotlin Coding Conventions](https://kotlinlang.org/docs/coding-conventions.html#source-file-names)",
            "Should be in its own file according to [Kotlin Coding Conventions](https://kotlinlang.org/docs/coding-conventions.html#source-file-names)",
            "Client models give us the freedom to decouple from backend schema, we need not have 1:1 parity, in fact, we shouldn't unless we think there's nothing the backend could improve on.\r\n\r\nThis many attributes in a single object is concerning, at the very minimum. I understand it can be complex, but by doing this, we are disseminating complexity instead of managing it. We should try to refine the models, and provide as the public API a clear, concise, usable definition. As of now, I only know that the fields `id`, `name`, and `supplierCode` will be given, everything else I have to go dig into logs, examples, and tests to try and see what the actual data looks like. This means I not only have to make sure I do that huge effort, but I have to continually do so, because there's not going to be a compiler to catch any changes made here which will impact any users of these structures",
            "[Here's a good reference](https://github.aexp.com/amex-eng/m1-msl/tree/4c8cef089ab72972a9a9164ca728ee7d1906ee55/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/models/api/message), which while imperfect, shows a very clear modeling of a distinctly complex type hierarchy. "
        ]
    },
    {
        "44225": [
            "Nit-ish:\r\n\r\nGiven we're inside of `OffersOverviewLabels` I personally don't think we need to reiterate `Labels` here, we'll know that from the enclosing scope. No outright dictation on how to do this per conventions, but related section [here](https://kotlinlang.org/docs/coding-conventions.html#class-layout)",
            "Long-term:\r\nI think this makes sense for the time being, but I do think we should be doing this as soon as we get the data from the BSC. If we know we have to fulfill some enumerable constraint, we should do that ASAP, so there's as few places to potentially create bugs in that flow as possible",
            "Yeah, but that would be in BSC to be clear, which could impact other consumers if they exist. Not saying a must, but rather, that's the \"ideal\" situation. We don't want to require all consumers to validate all inputs, else if they do, they all must be individually maintained and validated, and will be prone to their own bugs"
        ]
    },
    {
        "43964": [
            "Why is this change here?",
            "These honestly are super similar, we really should investigate uplift here. \r\n\r\nWe're using the exact same atttributes, we could instead define an abstraction, `OpeningAction`, something similar to below pseudocode\r\n\r\n```kotlin\r\nsealed class OpenAction(\r\n    val iconName , val title, val analyticsId) {\r\n    \r\n    data class Link(iconName, title, analyticsId) : OpenAction(...) {}\r\n    \r\n    data class Map(...same as link...) : OpenAction(...) { }\r\n}\r\n```",
            "We end up slicing all code which uses these types functionally by 75%~ roughly",
            "Does this need to be a single pull request? It's very very challenging to review when there's 1000+ new lines. I'm trying to go through it, but the context required to graps what's going on is immense.",
            "Would be reusable, just for example",
            "We really shouldn't use acronyms, it's opaque, error prone, and never worth the cost to a new developer when compared to the loss of context.\r\n\r\nSome good resources:\r\n- [Kotlin - Classes should be nouns](https://kotlinlang.org/docs/coding-conventions.html#choose-good-names)\r\n- [Wikipedia (java)](https://en.wikipedia.org/wiki/Naming_convention_(programming)#Java)\r\n- [DotNet](https://github.com/dotnet/docs/blob/main/docs/standard/design-guidelines/general-naming-conventions.md)\r\n- [Golang](https://go.dev/wiki/CodeReviewComments#initialisms)",
            "What type of data is in this `icon*` fields? This is pretty non-descriptive honestly.\r\n\r\nIs this a URL? A NDL icon name? Client specific implementation?\r\n\r\nAlso, are clients able to be sent an invalid value? I suspect they would, which would mean we need to be more rigiously enforcing things like non-emptiness and the patterning where applicable",
            "This `when` should be an `if`, it's a binary conditional\r\n\r\n[Kotlin Std Convention Ref](https://kotlinlang.org/docs/coding-conventions.html#if-versus-when)",
            "I pretty strongly feel like we should have an `enum` modeling this. \r\n\r\nFrom what I can see it seems way too direct a map onto this icon set to do anything but. \r\n\r\nAlso, why do we introduce null here? It may be valid, but ideally, we communicate (from the point at which we the `feature/offers` flow) know the client didn't provide it, we should define some unknown/undefined enum value such that the `null` turns into a rich, non-null, explicitly testable and known flow. Nulls, especially when they profliferate, are so interchangeable they can severly handicap us, but we won't know until they start to :sweat-smile:",
            "Yeah, but I mean, even so, I think this is a huge pull request. I'm focused on this and this alone and it's still alot. I haven't even gotten through 25%, and what I did was the most straightforward. \n\nIt's really challenging to review large puill requests (and I know this is funny coming from me, the king of massive pull requests), I want to feel confident it's going to work when I approve and let it merge to main, but it's increasingly challenging to feel like that the larger it gets.",
            "Could instead do something like this. This does also clean up the logic inside of `isOnlineAndInStore()` to be clear. Like would want to move that to there, but currently it seems pretty fragile if I'm candid.\r\n\r\nAlso this replacement would have to live in the `companion object` , to be clear\r\n\r\n```suggestion\r\n        fun List<MetaData.Merchant.RedemptionType>.getAvailableLabel(\r\n            availability: OfferAvailability\r\n        ) = if (isNotEmpty()) {\r\n            if (containsAll(MetaData.Merchant.RedemptionType.entries)) availability.onlineAndAtLocation else availability.online\r\n        } else availability.atLocation\r\n\r\n```",
            "### Don't skip small tasks\r\nClean up almost never happens, if we're being realistic. I'm personally pretty strongly opposed to the practice of \"kicking the can\", here and everywhere. I would point to something like [this article](https://chanind.github.io/2019/07/13/code-cleanup-2-minute-rule.html) for background on this. This is such a small lift, and without doing it now, it will never occur (almost certainly). This is nominal effort to make the change now, a change that hasn't been made on the source of this code, which is evidence of just how unlikely the future clean up would be.\r\n\r\n### Duplication\r\nI want to pivot a bit here, because the portion below really jumped out as a red flag to me\r\n> Just copy/pasted from existing offers labels\r\n\r\nWe should functionally never be duplicating, let alone actually copy-pasting whole data classes. I would say never personally, but I'll weaken it to almost never, to keep discussion productive. I've yet to see personally a case where code duplication was actually the right answer. I've seen it as the answer chosen, but that's not the goal; we don't want to replicate we want to strive for the ideal in each line we merge.\r\n\r\n\r\nFor a better solution, we could trivially use the shared fields in a common way, reducing dependant code. I can see this is a bigger issue than just this pull request. I see outright duplication of functionalities that could be erased by the below approach. \r\n\r\nFor example, we duplicate functionality [here](https://github.aexp.com/amex-eng/m1-msl/blob/2908d22259b065900019b5e01ffbd9fd2ee44dd8/features/offers/src/main/java/com/americanexpress/mobileone/overview/normalizer/OffersCommonNormalizer.kt#L49) and [here](https://github.aexp.com/amex-eng/m1-msl/blob/5f9d98dc9d1fe521ad370545d9bb0e04355d920e/features/offers/src/main/java/com/americanexpress/mobileone/offersv3/OffersV3NormalizerUtil.kt#L77). \r\n\r\nThese are functionally identical, written with different signatures, returning the same thing, with the requirement of maintaining tests for either. I would highly encourage taking a deep look at some of the patterns we follow here, and being open to meaningful uplifts, as I think they carry genuine value that could change how painful something is at a feature level to maintain, upgrade, and create in the future.\r\n\r\n\r\n```kotlin\r\nsealed class CallToAction<T : String?>() {\r\n    abstract val onlineAndAtLocation: String\r\n    abstract val atLocation: String\r\n    abstract val online: String\r\n    abstract val iconCart: T\r\n    abstract val iconDesktop: T\r\n\r\n    data class Strict(\r\n        override val onlineAndAtLocation: String,\r\n        override val atLocation: String,\r\n        override val online: String,\r\n        override val iconCart: String,\r\n        override val iconDesktop: String\r\n    ) : CallToAction<String>()\r\n\r\n    data class Lenient(\r\n        override val onlineAndAtLocation: String,\r\n        override val atLocation: String,\r\n        override val online: String,\r\n        override val iconCart: String? = null,\r\n        override val iconDesktop: String? = null\r\n    ) : CallToAction<String?>()\r\n}\r\n```\r\n",
            "This doesn't clear up my question though, can these values be empty? Is the string `\"\"` valid, or will clients throw exceptions, thus we should catch at MSL (in order to fulfill our BFF obligation). We have a single test implementation, with no empty values, so I would guess we are not intending these to be empty. If that would create issues, we should define it as so.\r\n\r\nFurthermore, I do in fact believe these conform to the NDL icon names as I originally suggested. Please look at [these definitions](https://github.aexp.com/amex-eng/m1-msl/blob/abdb34b1bfa5a1920568b529c8cff374cef395d2/features/feature-common/src/main/java/com/americanexpress/mobileone/features/common/model/PanelIcon.kt#L3) and consider usage therein. There's no reason to redefine, and make ourselves able to pass invalid data, when we have such reasonably strict guarantees.",
            "Why are we using a `sequential` here?",
            "Really don't think we should be doing this supression, there's a reason for these rules ultimately"
        ]
    },
    {
        "43946": [
            "The intention here is reverting this exact behavior, there was emerge in which I had accidentally done so. It is preventing sync PR\u2019s from going through"
        ]
    },
    {
        "44987": [
            "Is this needed?",
            "Do we need to keep this, at what point can we remove if so? "
        ]
    },
    {
        "44914": [
            "Love this setup by the way",
            "We should externalize some of these test payloads, so we can reuse and avoid these large diffs",
            "I'll raise a change today with what I'm thinking. It's worked superbly well for valgen thus far",
            "I personally don't love this naming. Not only are they hard to tell the difference in the order of (when someone inevitably has to solve for a test broken due to it), they don't communicate much about the content, nor what boundaries the different instances represent.\r\n\r\nI think it makes using them much more challenging, as we can't reason about them without jumping into the content itself",
            "Should this be `NoComponentsError`?\r\n\r\n```suggestion\r\n    is SduiBuilderError.BuildError.NoComponentsError -> EnricherError.BuilderError.NoComponentsError\r\n```",
            "If we left this [code](https://github.aexp.com/amex-eng/m1-msl/pull/44914/files#r3569864) as is, we'd never hit this debug.\r\n\r\nMaybe a point to potentially improve, we should link these enums with the messages explicitly. The data objects can have some generic top-level field which is their `baseMessage` which they serve via some `message` (default implementation is just the `baseMessage`)\r\n\r\n\r\n```kotlin\r\nsealed class SduiError(val baseMessage: NotBlankString) {\r\n    val message: NotBlankString\r\n        get() = baseMessage\r\n}\r\n```",
            "This is personally what I used in ValGen, I thought it worked really nicely.\r\n\r\n[Here's the overview from a composite message with components](https://github.aexp.com/amex-eng/m1-msl/blob/bcba9e171b44c838959315b233aa1baddd6c642b/backend-service-clients/messaging-v2-service-client/chat-service-client/src/testFixtures/java/com/americanexpress/mobileone/bsc/chat/conversation/client/conversation/messages/FakeClientCompositeMessage.kt#L43-L85)\r\n\r\n[And here's the shared values we used to intentionally set aside \"known, fixed, non-boundary values\" for consistent usage without the overhead of changing in multiple places.](https://github.aexp.com/amex-eng/m1-msl/blob/bcba9e171b44c838959315b233aa1baddd6c642b/backend-service-clients/messaging-v2-service-client/chat-service-client/src/testFixtures/java/com/americanexpress/mobileone/bsc/chat/conversation/client/conversation/FakeClientCommonValues.kt#L38-L176)",
            "Can understand that for sure",
            "I agrue we shouldn't depend at all on any non-functional boundaries, to be clear. Unique text doesn't affect a test, thus we should ideally not care about it (except for cases where it would affect the test of course). Ultimately just a focus on testing boundaries intentionally"
        ]
    },
    {
        "44876": [
            "The only external facing change that occured",
            "No more potential issues due to error leaking",
            "Tight bound from type-safety guarantees ",
            "Build is failing but I have to leave, I think it does a good job highlighting the point though.\r\n\r\nLet me know if you have any questions @zsun3",
            "This can be unit tested to guarantee there's no impact, I don't see what risk there could be. Something existing is not a reason why we ought to keep it, else we will quickly snowball to unmanageable. \r\n\r\nThis is a no-op change, it doesn't break anything and can be assertably proven for all inputs to yield identical outputs. In doing so, we prove, via induction, that there's guaranteed to be no impact.\r\n\r\nPlease tell me if I'm missing anything, I'm not trying to be a blocker, but also, this is a very feasible win with some super meaningful upside and reduction in risk. "
        ]
    },
    {
        "44821": [
            "Currently we rely on the assumption that if defined, the entire set of `enum.entries`  is case insensitive, which lets us use a factory to avoid registering for every `enum`, and can even allow us to register the factory globally and pick up the `@CaseInsensitve` annotations on types via introspection a single time. \r\n\r\nElse we will have to do dynamically, which is a non-trivial cost, and usage is much more fragile at that point. \r\n\r\nIt's doable, but I don't see a reason you'd only want a single field to be case-insenstive, at least not for how much it'd cost us in terms of perf and DX.",
            "No, we check the class definition to be `isEnum` in the factory resolution\r\n\r\n```kotlin\r\nobject CaseInsensitiveEnumJsonAdapterFactory : JsonAdapter.Factory {\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    override fun create(\r\n        type: Type,\r\n        annotations: MutableSet<out Annotation>,\r\n        moshi: Moshi\r\n    ): JsonAdapter<*>? = takeIf { type.rawType.isEnum && type.rawType.isAnnotationPresent(CaseInsensitive::class.java) }\r\n        ?.let { CaseInsensitiveEnumJsonAdapter(type.rawType as Class<out Enum<*>>) }\r\n        ....\r\n}\r\n```",
            "Note, we can't enforce the annotation is only on `enum` classes as the JVM can't truly tell them apart technically (it can, but not in the IR form, which is key)",
            "Great to hear this was a nice way to get visibility, going to be doing something similar for another one, hopefully can arm the team with some pretty nice solutions. Long term goal is getting us on a more \"type-driven development\" path long-term"
        ]
    },
    {
        "44816": [
            "What do we do in this scenario? To me, this is almost always an approach that we shouldn't take, unless we are seeking to be resilient to arbitrary values being received here.\r\n\r\nThis will catch everything, meaning we can no longer meaningfully fail to deserialize this enum, functionally making it identical to a string. This gives us all the issues of strings, with the added cost of the perception of type-safety (via deception...).\r\n\r\nReally think we should avoid this, pretty strong view. In general, unless there's defined behavior we're expecting, and this is a meaningful category, this is functionally an \"intentional bug\" in my view.",
            "Here, `null` and `asd;flkjg;lkjasf` will be treated identically, is that the intention? `active` will also be treated the same, as it will fallback. This is the risk of fallback, to be clear, we've turned this enum class, which presumably has a domain less than the set of all strings, into a regular string. This isn't unique to this pull request, but is a concern IMO MSL wide"
        ]
    },
    {
        "44695": [
            "Moved up for reuse by external button",
            "Reoprganized a bit",
            "\r\nLinted requires use-site annotations in Kotlin 2.1+ (only going to write this comment a single time to not spam)",
            "We aren't actually sent this I don't think but it was unclear to me, went with flexible approach for the interim",
            "Lol funny you said, but yes, it fails linting now due to version uplift for Kotlin",
            "[Link to comment where I outlined this in anticipation](https://github.aexp.com/amex-eng/m1-msl/pull/44695#discussion_r3557584)",
            "This implementation is how the `Enumerated<T>` is designed to be used, tiny refactor as I had to change anyways",
            "I was avoiding potentially invalid setups in test data was the thinking.\r\n\r\nOverall I don't like this approach as a whole, to be clear",
            "There's no `NOT_SUPPORTED` given by backend, we are interpolating this based on `type` + `stlye` logic\r\n\r\n[Code in question](https://github.aexp.com/amex-eng/m1-msl/blob/62c1ac20a2ac6160ffe36a62d29936b3296664c9/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/mappers/composite/CompositeMessageMapper.kt#L294-L301)",
            "Ditto [this](https://github.aexp.com/amex-eng/m1-msl/pull/44695#discussion_r3557623), if we changed to this we'd have deserialization exceptions",
            "Shoot this is on me, the payload I sent had this included\r\n",
            "Updated this test, we should fail in this scenario. See the [backend contract](https://github.aexp.com/pages/amex-eng/askamex-swagger-mobile/) for reference as to data expectations\r\n\r\n<img width=\"1261\" alt=\"image\" src=\"https://github.aexp.com/amex-eng/m1-msl/assets/17603/105201f4-a092-494e-892e-86fea568a8be\">\r\n",
            "Resovled",
            "This isn't backend, this is for clients, which as discussed are not expecting a value here. I default to simplify instantatnion in test data",
            "I'm unsure what you mean, are you saying I should add static imports?\r\n\r\nPersonally I think this is much more clear given the similarity of naming",
            "Ah, the choice here was intentional, interesting that you prefer, is it just line length? I'm only asking to try and undertsand the perspective a bit, it's not mine currently but I'm also not closed off to my current approach having flaws.\r\n\r\nThere's a lot of complex type mapping happening in this file, hence the focus on clarity above all, though it definitely does make it a bit verbose. I wish IntelliJ still had the intention for `add type alias` because if it was a smoother workflow I'd certainly use it here and solve for brevity and clarity.",
            "This is actually a great point, updating"
        ]
    },
    {
        "44617": [
            "Can we name this event, ie. this could be:\r\n\r\n```suggestion\r\n    fun emitFollowUpBenefitsEvent(): SseProcess\r\n```\r\n\r\nSorry just unclear as a first-time reader what \"event\" means.\r\n\r\nAlso, we're starting a new `SseProcess` here, are we going to be reusing this I assume? If so something like the below may be better\r\n\r\n```suggestion\r\n    fun followUpBenefits(): SseProcess\r\n```",
            "I'd request the changes here honestly, it's small, this is net new, and solutions start in pull requests like these :) Sorry, don't want to be too stiff, but this is an easy win :)",
            "[2 minute rule](https://reclaim.ai/blog/2-minute-rule) is my rule of thumb personally",
            "Approved! Thanks, sorry just trying a new approach on these to try and help the team, hopefully didn't come off poorly!"
        ]
    },
    {
        "44465": [
            "Nit:\r\nPersonally I think I'd make this parameter a receiver, ie:\r\n\r\n```kotlin\r\n        private fun NonEmptyList<AvailableOffer.Card>.normalizeNonEmptyOffers()-....\r\n```",
            "Really like this scope management here personally, traversing the scope via `with(...) {}` keeps the promiximity of relevant attributes really close",
            "Whenever anyone asks the reason for my crusade of \"type-driven development\", this will be a link I send. This entire segment of code, while sensible in this setting, is totally unneeded, and I think very anti-patterny personally. \r\n\r\nWith sufficiently tight type boundaries we could avoid this altogether, and via a value class with some enforced initializer, we could tighten the boundaries to fit any variety of conditions as the needs arise.",
            "I mean this is the best way @jtorr64 , to be clear. Given the constraints I think I'd do something similar, but also accepting the constraints is not something I'm good at :) ",
            "At this point we're fully decoupled from any and all backends as far as our type-safety is concerned, we definitely don't have to care about the data source or it's constraints. We instead must only depend on the exposed constraints defined by `Client` models. \r\n\r\nIf the `Client` guarantees to us, that somehow someway, we will get an `enum` , and that `NONE` is in there, and it will enforce these, we stop having to be concerned with the BSC this far from the actual HTTP call. If we don't,  we have to keep the entire system in our mind, the whole time we write code",
            "I'd posit it's not whether they're fine with it, but whether it's nullable. \r\n\r\nSomething being an amalgamation of two types in a shared hierarchy isn't a \"solution\" in my view. These are seperable or they aren't, and the fields are present, optional, or excluded, but all of this is purely bound to the info being communicated, not a preference. \r\n\r\nI know it sounds absoluteist, but it does make clear the responsibility. Ultimately, how clients implement is up to them, they can ignore type discriminators if they want, heck they can parse it as a string blob. None of that changes the \"why\" for us. The process of explicit discrimination gives us compile-time guarantee, and erases a ton of possible issues, that our data looks a certain way. If we know \"in all happy scenarios it will look like this\" we gain nothing at MSL from weakening it, even if clients won't use it. These things allow us to avoid the invasion of conditionals, the fragility of tests checking nulls, and the need to have a test in the first place.",
            "Discussed comments, all of mine are okay to be merged as is, ongoing effort but very much not meant for scope of these changes! "
        ]
    },
    {
        "44269": [
            "~~This is concerning, and should be resolved prior to merge, at least for all new additions~~\r\n\r\n~~We should not have multiple top-level (not nested) classes, of any types, defined in a single file. This is pretty explicitly declared in the [official Kotlin Coding Convention](https://kotlinlang.org/docs/coding-conventions.html#source-file-names)~~\r\n\r\nI was wrong here, thanks @czschwar for checking me on this",
            "Also, acronyms are something we should avoid, and should be seen as a bad practice in general. \r\n\r\nThis is because honestly, I don't know what `Lxp` means, and I don't know where to look, or who to ask (not that those are valid solutions, but I'm trying to highlight how hard it can be from a reviewers perspective)",
            "We should be using [`JsonWebToken`](https://github.aexp.com/amex-eng/m1-msl/blob/ec632576b645969d5470db5edee4cb8184b35cfe/common/msl-common/src/main/java/com/americanexpress/intlmobl/app/clientrequest/common/JsonWebToken.kt#L7) for these, we have a type-safe representation, we should prefer that over a plain string",
            "There's a type identifier in here, surely we can discriminate? This really is scary long-term as I don't believe these fields are truly supported as defined by the model.\r\n\r\nThat is, I could using this constructor, create an invalid representation of data. If you want to discuss how to handle this and solve for it I'm more than happy to do so, please feel free to reach out and we can discuss!\r\n\r\nA couple of references for a set of hierarchies I've worked to illuminate and for which the outcomes have been dramatically improved:\r\n* [ApiMessage](https://github.aexp.com/amex-eng/m1-msl/blob/337437234f119407265f3ee8d657a6e5f5557731/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/models/api/message/ApiMessage.kt#L14-L64)\r\n* [ApiConversationResponse](https://github.aexp.com/amex-eng/m1-msl/blob/0ad74e98db7f19b7a080fbdc5da82cd8f407ed49/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/models/api/ApiConversationResponse.kt#L15)\r\n  * Prior this was a [Passthrough map](https://github.aexp.com/amex-eng/m1-msl/blob/b7fcc4042838c9aaf6bd4b21ab390a813c4203c1/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/ConversationApiModel.kt#L131-L137), just to be clear",
            "Surely these two at least are not nullable I'd hope. If they are I think they warrant a discussion about the minimum we can accept from backends.\r\n\r\nUltimately, your data class states that we can accept an object `{ }`, which is a equally valid, and identical type of room, to a fully non-null representation. That concerns me to be candid",
            "[Should be in it's own file per coding conventions](https://kotlinlang.org/docs/coding-conventions.html#source-file-names)",
            "Should be in its own file according to [Kotlin Coding Conventions](https://kotlinlang.org/docs/coding-conventions.html#source-file-names)",
            "Comments aren't type safe, and can fall out of sync with code, we shouldn't include them as we can't trust them to accurate",
            "Should be in its own file according to [Kotlin Coding Conventions](https://kotlinlang.org/docs/coding-conventions.html#source-file-names)",
            "Should be in its own file according to [Kotlin Coding Conventions](https://kotlinlang.org/docs/coding-conventions.html#source-file-names)",
            "Should be in its own file according to [Kotlin Coding Conventions](https://kotlinlang.org/docs/coding-conventions.html#source-file-names)",
            "Client models give us the freedom to decouple from backend schema, we need not have 1:1 parity, in fact, we shouldn't unless we think there's nothing the backend could improve on.\r\n\r\nThis many attributes in a single object is concerning, at the very minimum. I understand it can be complex, but by doing this, we are disseminating complexity instead of managing it. We should try to refine the models, and provide as the public API a clear, concise, usable definition. As of now, I only know that the fields `id`, `name`, and `supplierCode` will be given, everything else I have to go dig into logs, examples, and tests to try and see what the actual data looks like. This means I not only have to make sure I do that huge effort, but I have to continually do so, because there's not going to be a compiler to catch any changes made here which will impact any users of these structures",
            "[Here's a good reference](https://github.aexp.com/amex-eng/m1-msl/tree/4c8cef089ab72972a9a9164ca728ee7d1906ee55/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/models/api/message), which while imperfect, shows a very clear modeling of a distinctly complex type hierarchy. "
        ]
    },
    {
        "44225": [
            "Nit-ish:\r\n\r\nGiven we're inside of `OffersOverviewLabels` I personally don't think we need to reiterate `Labels` here, we'll know that from the enclosing scope. No outright dictation on how to do this per conventions, but related section [here](https://kotlinlang.org/docs/coding-conventions.html#class-layout)",
            "Long-term:\r\nI think this makes sense for the time being, but I do think we should be doing this as soon as we get the data from the BSC. If we know we have to fulfill some enumerable constraint, we should do that ASAP, so there's as few places to potentially create bugs in that flow as possible",
            "Yeah, but that would be in BSC to be clear, which could impact other consumers if they exist. Not saying a must, but rather, that's the \"ideal\" situation. We don't want to require all consumers to validate all inputs, else if they do, they all must be individually maintained and validated, and will be prone to their own bugs"
        ]
    },
    {
        "43964": [
            "Why is this change here?",
            "These honestly are super similar, we really should investigate uplift here. \r\n\r\nWe're using the exact same atttributes, we could instead define an abstraction, `OpeningAction`, something similar to below pseudocode\r\n\r\n```kotlin\r\nsealed class OpenAction(\r\n    val iconName , val title, val analyticsId) {\r\n    \r\n    data class Link(iconName, title, analyticsId) : OpenAction(...) {}\r\n    \r\n    data class Map(...same as link...) : OpenAction(...) { }\r\n}\r\n```",
            "We end up slicing all code which uses these types functionally by 75%~ roughly",
            "Does this need to be a single pull request? It's very very challenging to review when there's 1000+ new lines. I'm trying to go through it, but the context required to graps what's going on is immense.",
            "Would be reusable, just for example",
            "We really shouldn't use acronyms, it's opaque, error prone, and never worth the cost to a new developer when compared to the loss of context.\r\n\r\nSome good resources:\r\n- [Kotlin - Classes should be nouns](https://kotlinlang.org/docs/coding-conventions.html#choose-good-names)\r\n- [Wikipedia (java)](https://en.wikipedia.org/wiki/Naming_convention_(programming)#Java)\r\n- [DotNet](https://github.com/dotnet/docs/blob/main/docs/standard/design-guidelines/general-naming-conventions.md)\r\n- [Golang](https://go.dev/wiki/CodeReviewComments#initialisms)",
            "What type of data is in this `icon*` fields? This is pretty non-descriptive honestly.\r\n\r\nIs this a URL? A NDL icon name? Client specific implementation?\r\n\r\nAlso, are clients able to be sent an invalid value? I suspect they would, which would mean we need to be more rigiously enforcing things like non-emptiness and the patterning where applicable",
            "This `when` should be an `if`, it's a binary conditional\r\n\r\n[Kotlin Std Convention Ref](https://kotlinlang.org/docs/coding-conventions.html#if-versus-when)",
            "I pretty strongly feel like we should have an `enum` modeling this. \r\n\r\nFrom what I can see it seems way too direct a map onto this icon set to do anything but. \r\n\r\nAlso, why do we introduce null here? It may be valid, but ideally, we communicate (from the point at which we the `feature/offers` flow) know the client didn't provide it, we should define some unknown/undefined enum value such that the `null` turns into a rich, non-null, explicitly testable and known flow. Nulls, especially when they profliferate, are so interchangeable they can severly handicap us, but we won't know until they start to :sweat-smile:",
            "Yeah, but I mean, even so, I think this is a huge pull request. I'm focused on this and this alone and it's still alot. I haven't even gotten through 25%, and what I did was the most straightforward. \n\nIt's really challenging to review large puill requests (and I know this is funny coming from me, the king of massive pull requests), I want to feel confident it's going to work when I approve and let it merge to main, but it's increasingly challenging to feel like that the larger it gets.",
            "Could instead do something like this. This does also clean up the logic inside of `isOnlineAndInStore()` to be clear. Like would want to move that to there, but currently it seems pretty fragile if I'm candid.\r\n\r\nAlso this replacement would have to live in the `companion object` , to be clear\r\n\r\n```suggestion\r\n        fun List<MetaData.Merchant.RedemptionType>.getAvailableLabel(\r\n            availability: OfferAvailability\r\n        ) = if (isNotEmpty()) {\r\n            if (containsAll(MetaData.Merchant.RedemptionType.entries)) availability.onlineAndAtLocation else availability.online\r\n        } else availability.atLocation\r\n\r\n```",
            "### Don't skip small tasks\r\nClean up almost never happens, if we're being realistic. I'm personally pretty strongly opposed to the practice of \"kicking the can\", here and everywhere. I would point to something like [this article](https://chanind.github.io/2019/07/13/code-cleanup-2-minute-rule.html) for background on this. This is such a small lift, and without doing it now, it will never occur (almost certainly). This is nominal effort to make the change now, a change that hasn't been made on the source of this code, which is evidence of just how unlikely the future clean up would be.\r\n\r\n### Duplication\r\nI want to pivot a bit here, because the portion below really jumped out as a red flag to me\r\n> Just copy/pasted from existing offers labels\r\n\r\nWe should functionally never be duplicating, let alone actually copy-pasting whole data classes. I would say never personally, but I'll weaken it to almost never, to keep discussion productive. I've yet to see personally a case where code duplication was actually the right answer. I've seen it as the answer chosen, but that's not the goal; we don't want to replicate we want to strive for the ideal in each line we merge.\r\n\r\n\r\nFor a better solution, we could trivially use the shared fields in a common way, reducing dependant code. I can see this is a bigger issue than just this pull request. I see outright duplication of functionalities that could be erased by the below approach. \r\n\r\nFor example, we duplicate functionality [here](https://github.aexp.com/amex-eng/m1-msl/blob/2908d22259b065900019b5e01ffbd9fd2ee44dd8/features/offers/src/main/java/com/americanexpress/mobileone/overview/normalizer/OffersCommonNormalizer.kt#L49) and [here](https://github.aexp.com/amex-eng/m1-msl/blob/5f9d98dc9d1fe521ad370545d9bb0e04355d920e/features/offers/src/main/java/com/americanexpress/mobileone/offersv3/OffersV3NormalizerUtil.kt#L77). \r\n\r\nThese are functionally identical, written with different signatures, returning the same thing, with the requirement of maintaining tests for either. I would highly encourage taking a deep look at some of the patterns we follow here, and being open to meaningful uplifts, as I think they carry genuine value that could change how painful something is at a feature level to maintain, upgrade, and create in the future.\r\n\r\n\r\n```kotlin\r\nsealed class CallToAction<T : String?>() {\r\n    abstract val onlineAndAtLocation: String\r\n    abstract val atLocation: String\r\n    abstract val online: String\r\n    abstract val iconCart: T\r\n    abstract val iconDesktop: T\r\n\r\n    data class Strict(\r\n        override val onlineAndAtLocation: String,\r\n        override val atLocation: String,\r\n        override val online: String,\r\n        override val iconCart: String,\r\n        override val iconDesktop: String\r\n    ) : CallToAction<String>()\r\n\r\n    data class Lenient(\r\n        override val onlineAndAtLocation: String,\r\n        override val atLocation: String,\r\n        override val online: String,\r\n        override val iconCart: String? = null,\r\n        override val iconDesktop: String? = null\r\n    ) : CallToAction<String?>()\r\n}\r\n```\r\n",
            "This doesn't clear up my question though, can these values be empty? Is the string `\"\"` valid, or will clients throw exceptions, thus we should catch at MSL (in order to fulfill our BFF obligation). We have a single test implementation, with no empty values, so I would guess we are not intending these to be empty. If that would create issues, we should define it as so.\r\n\r\nFurthermore, I do in fact believe these conform to the NDL icon names as I originally suggested. Please look at [these definitions](https://github.aexp.com/amex-eng/m1-msl/blob/abdb34b1bfa5a1920568b529c8cff374cef395d2/features/feature-common/src/main/java/com/americanexpress/mobileone/features/common/model/PanelIcon.kt#L3) and consider usage therein. There's no reason to redefine, and make ourselves able to pass invalid data, when we have such reasonably strict guarantees.",
            "Why are we using a `sequential` here?",
            "Really don't think we should be doing this supression, there's a reason for these rules ultimately"
        ]
    },
    {
        "43946": [
            "The intention here is reverting this exact behavior, there was emerge in which I had accidentally done so. It is preventing sync PR\u2019s from going through"
        ]
    },
    {
        "43360": [
            "Sorry, odd check-in issues as I had to recently fully reclone MSL, and didn't realize my `.git/info/exclude` got removed in the process. Should be good now, sorry for the confusion"
        ]
    },
    {
        "43260": [
            "Personally, given it's an immutable field, I (as a result of Kotlin official coding convention) use a property as opposed to function as a rule.\r\n\r\n[Convention Link](https://kotlinlang.org/docs/coding-conventions.html#functions-vs-properties)\r\n\r\n\r\nUpdated code:\r\n```suggestion\r\nprivate val String.isEnrollmentStatusActiveLike: Bool\r\n    get() = PayflexEnrollmentStatus.getEnrollmentStatus(this) in setOf(\r\n        PayflexEnrollmentStatus.ACTIVE,\r\n        PayflexEnrollmentStatus.REINSTATE,\r\n        PayflexEnrollmentStatus.ENROLLED,\r\n    )\r\n```",
            "Nit (kind of):\r\nAs a general rule, `val`'s name matches the `type`. Is there a compelling reason not to  follow that pattern here?",
            "Function should be a property, [convention link](https://kotlinlang.org/docs/coding-conventions.html#functions-vs-properties)",
            "Can we assume the false branch returns `false` for this, instead of `null`? I feel like the `false` is actually more correct, as if we are not `isCheckPayOverTimeToggledOnFeatureEnabled == true` we will never be `getPayOverTimeEligibility == true`, no? ",
            "Not applicable or in scope, but just a thought. This seems like a pretty prime opportunity for improvement, there's a pretty liberal usage of `null` throughout, and it feels like the types are extricable and separable on these null'd boundaries. It could help simplify the code immensely, by giving explicit closure on property presence, removing the need for all these null branch handlers.\r\n\r\nMore than happy to assist if it's unclear! Not at all in the scope of pull request, just to be explicit again",
            "We should make these an `enum` in a separate file. We're enforcing these values exactly, and using them (redefined) in tests. The field they model is certainly enumerated.",
            "This is a great smell for when something should be an `enum` as opposed to strings. \r\n\r\nIf we're so coupled to the values we're defining them like this in tests, it's definitely a moment to ask \"Should it be enumerated?\"",
            "I'm not convinced suppressing this is the best approach. This file feels pretty huge to me, it's 500+ lines, is there really nothing we can do to split it up? These types of super-huge files inevitably end up as hard-to-maintain tech-debt sources simply as people avoid touching due to it being too large to grasp the scope of it for changes.",
            "Sorry, think I missed this but this should also be a `val` realistically"
        ]
    },
    {
        "43194": [
            "We were always mapping this to `Unit`, so I figured I'd save us the trouble. This is simpler as we don't have to coordinate between two different versions now, so made sense to me. Let me know if any concerns",
            "Can delete given no deserialization needed for `Unit`",
            "This was only used in `v1` , so I removed this + the logger",
            "No longer needed either, YAGNI until we need it in future",
            "this is dependant on the merging of the two below ramp-up pull requests in order to pass builds.\r\n\r\n* [Config #2074](https://github.aexp.com/amex-eng/m1-msl-configurations/pull/2074)\r\n* [Config #2075](https://github.aexp.com/amex-eng/m1-msl-configurations/pull/2075)"
        ]
    },
    {
        "43133": [
            "Valid improvement, actually was thinking about exactly this change being a good idea yesterday in the course of [this discussion](https://aexp-mobile-and-web.slack.com/archives/C5F2G3ATA/p1746027290144419?thread_ts=1727797633.556689&cid=C5F2G3ATA)",
            "Can we expose these in a `testFixtures` package? Reuse is definitely core to keeping tests scaleable in my opinion.",
            "Doesn't apply here a ton, but wanted to bring up potentially using a DSL to avoid the nested-`copy` headaches that sometimes become a problem with valgen `fakeApi` and `fakeClient` models, potentially via a similar DSL to the builder.\r\n\r\n",
            "A thought reading through some of these, what if we were to assign reasonable defaults where applicable? I think it would meaningfully allow us to describe \"default\" behavior. \r\nMind you, we could pretty simply configure a range of behaviors these from Moshi deserialization, depending on what we wanted.\r\n\r\nFirst two that jump to mind:\r\n* Via simple adapter, to ignore kotlin defaults\r\n* `@JsonQualifier` annotation usage to create a `@RequireJson` or similar annotation to denote elements which would need to be present even if they had a default value defined\r\n\r\nWe could also provide the defaults only in the builder, keeping the models transparent regarding defaultability, while allowing better re-use and developer experience (which realistically is what will drive interest and adoption at the end of the day)",
            "I'm not totally sold on why we need to allow UUID to be explicitly set, I feel like that only adds potential for misuse and hard to debug issues (or even identify, depending on the bug).\r\n\r\nWhat's the thinking here? For testing we shouldn't need it, no? As we can compare equality for processed nodes, and can expose `internal constructor` which could set the UUID for `test` flows where we absolutely needed it. I think this gives away a lot of guarantability regarding UUID's, which ultimately the value of UUID's are fully predicated on. Not in scope, just thinking on this "
        ]
    },
    {
        "42921": [
            "I think there's a discussion to be had around repition, and semantic scoping removing the need for such dense naming. We can discuss of course, not the place for it in this change, but just a thought, especially for these nested classes inside of type `TemplateTextComponent`"
        ]
    },
    {
        "42844": [
            "Had to enable usage of this in `ApiSelectorPreviewSelectionJsonAdapter`, as I don't want to be mandated to manually add adapters (harder to keep in sync, weird errors that are hard to trace during dev). \r\n\r\nI need to create a new instance of Moshi to avoid cyclic lookups in `ApiSelectorPreviewSelectionJsonAdapter`, as I want to lean on data class adapters, then manually apply assertion functions directly after they're constructed. \r\n\r\nTo an observe, this is still rendered as a `JsonDataException`, you still see the full line and JSON being parsed, plus exact location, and my error message appended. Should enable seamless debugging should the day come where we need it.",
            "Have to add the custom adapter which we're using inside the model for `PreviewSelection` in order to deserialize the model as expected.",
            "I actually found a way around this, going to leave comment though.\r\n\r\nWe avoid cyclic lookups now by explicit self-referencing in the factory, a lateinit that reuse's the moshi instance the factory is invoked with, and a anonymous adapter which uses said moshi instance for it's adapter resolution, explicitly stepping over itself. Pretty neat little optimization to avoid duplication of moshi instances",
            "There's some complexity here, specifically on the invocation of `create` not caching except for objects, as they are doing some fancy stuff internally. Really even my original solution is pretty poor, though it does externalize it and use an `Object` for the adapter, but I'm not confident it's correct, as I don't quite understand the Moshi code perfectly. \r\n\r\nThis forthcoming update is in line with their implementation though. [Here's a link for reference to how they handle these situations internally in their code](https://github.com/square/moshi/blob/master/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.kt#L30-L99)"
        ]
    },
    {
        "42833": [
            "Really really like this as an alternative to inheritance for these builders. Was mulling this a day or two ago, and this is much better than what I was roughing out locally",
            "This entire change should serve as a reference for visibility constraints, genuinely exceptional to see the intentionality around protecting core functionality while preserving future flexibility."
        ]
    },
    {
        "42823": [
            "Unused?",
            "Can we split this into it's own function? In general the goal was 1-2 \"call-depth\" per function, to keep them composable and succinct. I know it's annoying , but this call definitely sticks out quite a bit in the file.\r\n\r\nIdeally we'd define a function kind of like the below for surfacing the fact that we have two ways of creating `ClientComponent.Accessibility`. Organization wise I try to group related methods, so I'd personally place around line 203, below the existing `toClient` for `Accessibility`\r\n\r\n```kotlin\r\nprivate fun ApiInputComponent.Input.Date.ErrorTemplate.toClient(format: ApiInputComponent.Input.Date.Date.Format) =\r\n    ClientComponent.Accessibility(NotBlankString(string.format(format.toClient().accessibilityPattern)))\r\n\r\n```",
            "Here, I got rid of the `let` wrapping and brought it a bit more in line with the rest of the code, without changing a ton. Let me know thoughts\r\n\r\n```kotlin\r\nprivate fun ApiInputComponent.Input.Date.Date.toClient() = ClientInputComponent.Input.Date.Date(\r\n    error = ClientInputComponent.Input.Date.Date.Error(\r\n        message = NotBlankString(errorTemplate.string.format(format.toClient().presentationPattern)),\r\n        accessibility = errorTemplate.toClient(format)\r\n    ), pattern = DatePattern(NotBlankString(format.toClient().systemPattern))\r\n)\r\n```\r\n"
        ]
    },
    {
        "42709": [
            "Why are we falling back? Can we not just set a default where appropriate in the data class constructor? \r\n\r\nPersonally I really don't love Moshi's 'unknown fallback adapter' implementation, I don't think we as developers actually want to fall back to this in all unknown scenarios. I think filling in null's is reasonable depending on the constraints, but do we actually what to be immune to all errors on this field aside from receiving an integer as opposed to a string?",
            "This is certainly a misuse of inheritance from my perspective. We have no attributes here, we're not actually describing some set of attributes or behaviors, we are just making this a container, when in reality it's a misnomer at best",
            "Personally, for nullable fields, I default them to null if I'm using them in API models.\r\n\r\nThis is two fold:\r\n1. Our common moshi uses `nullSafeTypeAdapter`, meaning we handle nulls gracefully, so a default is not a behavior change\r\n2. Defaulting this `null` makes it easier to use realistic, scoped models in testing",
            "After finishing reading through changes I'm more certain in this viewpoint. Unless I'm somehow missing something massive this is a slam dunk imo"
        ]
    },
    {
        "42087": [
            "Nit: Is there any long-term potential to make this `null` something with explicit meaning? \r\n\r\nOnly reason, as a developer who's unfamiliar with this code, I found myself searching the code for insight into what this null actually translates into logically. Maybe something like `UNDEFINED` or `UNKNOWN`?"
        ]
    },
    {
        "42076": [
            "Why is this field nullable, where's the address directly below in `BusinessInformation` is not? ([link](https://github.aexp.com/amex-eng/m1-msl/blob/b679e8233d6c32ce56383edb49dc5a3fbf799c5b/backend-service-clients/supplementary-card-offers/supplementary-card-offers-onedata-client/src/main/java/com/americanexpress/mobileone/bsc/onedata/supplementaryCardOffers/SupplementaryCardOffersApiModel.kt#L133-L135))\r\n\r\nFurther, if it's nullable, is it guarantably non-empty when we do in fact receive it? If so, we should work to encode this here",
            "My only thinking was in scenarios where we do get empty, we can null it, thus reducing the branches we have to handle by half. We could also achieve this via defaulting to an empty list. Hidden semantics in nulls are generally bad is my only thinking, but I also know how the real world works and backends, so I trust here"
        ]
    },
    {
        "42065": [
            "Is this really nullable? Given it's the only attribute this doesn't make a ton of sense. If this is nullable, then `acquisitionMenu` is simply going to be `{}`, which should not produce different outputs than `acquisitionMenu` being absent.\r\n\r\nI may be missing some context, but it definitely feels like we should be able to make this assertably non-null based off type-theory alone"
        ]
    },
    {
        "41999": [
            "These protocol level failures are handled via our retrofit call adapter ([link](https://github.aexp.com/amex-eng/m1-msl/blob/be9427d86497105b443af1fc83959e18d94144bf/backend-service-clients/bsc-common/src/main/java/com/americanexpress/mobileone/bsc/common/retrofit/ResultAdapter.kt#L182-L198)) and don't need explicit handling at endpoints.\r\n\r\nThey will all fall back into the defined error type, which is why type `Nothing` is permissible (and `Unit` obviously)\r\n\r\nSome other examples:\r\n* [`MemberAccountsApi`](https://github.aexp.com/amex-eng/m1-msl/blob/1c8a5493cc769e17553186d65353097a9db0ed52/backend-service-clients/card-services/member-accounts-v2-client/src/main/java/com/americanexpress/mobileone/bsc/cardservice/memberAccountsV2/MemberAccountsApi.kt#L25)\r\n* [`OneCmsApi`](https://github.aexp.com/amex-eng/m1-msl/blob/3875e55681991ea0d8b711e14210c521e12a78a9/backend-service-clients/one-cms-client/src/main/java/com/americanexpress/mobileone/bsc/one/cms/OneCmsApi.kt#L25-L27)",
            "Totally acceptable, this is the huge upside of something like outcome, we can defer the handling of any and all failure modes arbitrarily. This allows us to handle it at the level we wish, with the fidelity we wish, without risk of the flow terminating due to unhandled exceptions or other fatal errors.\r\n\r\nIn fact, the [`ApiCallError`](https://github.aexp.com/amex-eng/m1-msl/blob/be9427d86497105b443af1fc83959e18d94144bf/backend-service-clients/bsc-common/src/main/java/com/americanexpress/mobileone/bsc/common/retrofit/ResultAdapter.kt#L71-L70) explicitly denotes itself as being for \r\n> All non-2xx responses",
            "Super nit: Uggo format (in my opinion)\r\n\r\nI know I know, but still wanted to comment :) Personally I find line-delimination in these short flows more readable, with and emphasis on segregation of happy and sad paths, with ideally the execute call on the same line as the end of function definition.\r\n\r\n```suggestion\r\n    override fun createOfferEnrollment(\r\n        request: CreateCardOfferEnrollmentClientRequest,\r\n    ) = api.createOfferEnrollment(request.toHeaders(), request.toApiRequest()).execute()\r\n        .map { TODO(\"M1-208346\") }\r\n        .mapError { TODO(\"M1-208341\") }\r\n\r\n```",
            "Beautiful use of value classes, love to see it",
            "Super Nit/Nit: Type aliases would help a ton with readability and writability of these Outcome types. Doesn't need to happen here and now, but if we're going to reuse them, make them easy to use and formal"
        ]
    },
    {
        "41941": [
            "I'm confused, don't we default to `junit.jupiter.testinstance.lifecycle.default=per_class` for MSL? How would this have any impact on a class in that case?"
        ]
    },
    {
        "41912": [
            "Guh"
        ]
    },
    {
        "41816": [
            "Nit: I personally don't like the `if () ... else` here just because `when` has closure guarantees. Up to you though. If we had [`guard` when clauses](https://kotlinlang.org/docs/control-flow.html#guard-conditions-in-when-expressions) enabled I'd leverage those, but will have to wait until then\r\n\r\n ```suggestion\r\nprivate fun ApiButtonComponent.Button.Navigation.Alignment.toClient(style: ApiButtonComponent.Button.Style): Navigation.Alignment =\r\n    when (style) {\r\n        ApiButtonComponent.Button.Style.INLINE -> when (this) {\r\n            ApiButtonComponent.Button.Navigation.Alignment.LEFT -> Navigation.Alignment.LEFT\r\n            ApiButtonComponent.Button.Navigation.Alignment.CENTER -> Navigation.Alignment.CENTER\r\n        }\r\n        else -> Navigation.Alignment.NOT_SUPPORTED\r\n    }\r\n```"
        ]
    },
    {
        "41608": [
            "Can we extract this parameter evaluation to a private function? Seems pretty hefty for inline and definitely threw me a bit reading through changes",
            "I took a pass at seeing what I could do to make this a bit more straightforward.\r\n\r\nMy main goal was removing the multiple code control statements (`return`'s here)\r\n\r\nLet me know what you think. I did run locally and it passes tests, just to be clear.\r\n\r\n```kotlin\r\nprivate fun Collection<*>?.hasMinimumAccounts() = (this?.size ?: 0) >= MIN_NUMBER_OF_ACCOUNTS\r\n\r\nprivate fun ApplyAllLabelsAddress.ApplyAllScreen.populateApplyAllScreenWithDemographics(\r\n    addressMetaData: AddressMetadata,\r\n    discriminator: ApplyAllLabelsAddress.Discriminator?,\r\n    isCorporate: Boolean,\r\n    tokenContainer: TokenContainer,\r\n    propagationResponse: NonEmptyList<PropagationClientResponse.AccountsToPropagate>?,\r\n    productType: ProductType,\r\n): ApplyAllScreen? = runIf(propagationResponse.hasMinimumAccounts()) {\r\n    propagationResponse.toDemographics(\r\n        tokenContainer.currentToken,\r\n        addressMetaData,\r\n        productType,\r\n        discriminator\r\n    ).let { demographics ->\r\n        ApplyAllScreen(\r\n            confirmLabel = confirmLabel,\r\n            continueLabel = continueLabel,\r\n            description = description,\r\n            eligibleAccounts = populateEligibleAddressableAccounts(\r\n                addressMetaData,\r\n                discriminator,\r\n                isCorporate,\r\n                tokenContainer\r\n            ),\r\n            header = header,\r\n            savingsAccountsLabel = savingsAccountsLabel.takeIf { tokenContainer.savingsTokens.hasMinimumAccounts() }\r\n                ?.format(tokenContainer.savingsTokens.size),\r\n            selectAllLabel = selectAllLabel.takeIf { propagationResponse.hasMinimumAccounts() },\r\n            topDisclaimer = topDisclaimer.takeIf { demographics.isNullOrEmpty() },\r\n            demographics = demographics\r\n        )\r\n    }\r\n}\r\n\r\n\r\nprivate fun ApplyAllLabelsAddress.ApplyAllScreen.populateEligibleAddressableAccounts(\r\n    addressMetaData: AddressMetadata,\r\n    discriminator: ApplyAllLabelsAddress.Discriminator?,\r\n    isCorporate: Boolean,\r\n    tokenContainer: TokenContainer,\r\n) = populateEligibleAccounts(\r\n    addressMetaData = addressMetaData,\r\n    discriminator = discriminator,\r\n    isCorporate = isCorporate,\r\n    tokenContainer = tokenContainer,\r\n    isProfileMailingAddressEnabled = true,\r\n    isResidentialAddressEnabled = true\r\n)\r\n\r\n```",
            "I'm unsure how you mean, these two functions give exactly equal output.\r\n\r\nThe below function execution:\r\n```kotlin\r\npropagationResponse.toDemographics(\r\n        tokenContainer.currentToken,\r\n        addressMetaData,\r\n        productType,\r\n        discriminator\r\n    )\r\n```\r\nReturns to us a type `List<ApplyAllScreen.Demographics>?`, there is no dependency on it's \"non-null\"-ness\r\n\r\nWhere we use `demographics`, we are calling `topDisclaimer.takeIf { demographics.isNullOrEmpty() }`, such that we only 'take' `topDisclaimer` when `demographics.isNullOrEmpty()`.\r\n\r\nThis code passes all tests, to be clear",
            "This function `populateApplyAllScreen` could be brought more in line with `populateApplyAllScreenWithDemographics`, and realistically I think it's a pretty important refactor. \r\n\r\nAlso, personally, returning a conditional lambda exec definitely seems like a pretty dicey pattern in my opinion. In these types of purely mechanical functions, operating on data statically, I really think it's a bit of a smell if you find yourself writing `return ...` frequently.\r\n\r\nHere's some kotlin convention documentation about the above comment:\r\n- [Single Exit Point in Lambda](https://kotlinlang.org/docs/coding-conventions.html#returns-in-a-lambda)\r\n- [Prefer Expression form of Conditional](https://kotlinlang.org/docs/coding-conventions.html#conditional-statements)\r\n- [Execute if not Null](https://kotlinlang.org/docs/idioms.html#execute-if-not-null)"
        ]
    },
    {
        "41589": [
            "This is so slick I'm so pleased that it was this simple"
        ]
    },
    {
        "41431": [
            "I don't think this is required given it's just being serialized via Jackson, no?",
            "Yeah I was misunderstanding here, given this is request ingestion, we do require this type specifier"
        ]
    },
    {
        "41098": [
            "Fixed this",
            "Fixed as well"
        ]
    },
    {
        "41090": [
            "Potential Nit (personal preference really):\r\n\r\nCould be sensible to add a safe default value for this new argument, to help mitigate changes where possible. There's an implicit assumption currently of `false` for this, making that explicit and communicating it clearly in function signature will also save future engineers the effort of validating that \"all but a few places this is false\", or \"unless hitting X flow this is always `false`\"",
            "Just a thought, lots of functions with `List<CardDataBean>` as first param, may make sense to turn this into a receiver for those functions, and alias the type. Could definitely make it easier to parse for those unfamiliar (like myself)"
        ]
    },
    {
        "41033": [
            "Could also do something similar to what I have implemented here, leveraging elvis operators. \r\n\r\nI also have a rename added in just to help clarity that I think will help make this look much cleaner,  but general gist remains the same regardless.\r\n\r\n```suggestion\r\n        ((sendMessageRequest.message as? CompositeMessageRequest)?.composite as? CompositeRequest.Accepted)?.agent as CompositeRequest.Accepted.Agent ?: agentId\r\n```",
            "Here's a choice that may also work, personally I like it more simply due to less nesting access and a explicit progression down the type as we proceed along.\r\n\r\n```suggestion\r\n    private fun extractAgentId(\r\n        agentId: String?,\r\n        sendMessageRequest: SendMessageRequest\r\n    ): String? = (((sendMessageRequest.message as? CompositeMessageRequest)\r\n        ?.composite as? AcceptedCompositeStatus)?.agent as? Present)?.agentId ?: agentId\r\n```\r\n\r\n",
            "We should implement this in the same pattern as the [`ReferenceImplementationController`](https://github.aexp.com/amex-eng/m1-msl/blob/762bd8435b3ec8f38c02bdb37431d1439a87bc18/features/reference-implementation/src/main/java/com/americanexpress/mobileone/referenceimplementation/ReferenceImplementationController.kt#L29-L35). I see how you approached, and it makes sense, but all new code should be matching the reference implementation at the time of writing.\r\n\r\n",
            "Honestly this could be parameterized pretty trivially, might be a good exercise just to get a feel for more scalable testing modalities. \r\n\r\n[Here's a good example](https://github.aexp.com/amex-eng/m1-msl/blob/a5ea9bc051dd7d574d005af1132f35e833d3ef06/core/functional/feature/src/test/kotlin/com/americanexpress/mobileone/featureflags/FeatureFlagsServiceKtTest.kt#L227-L250) by none other than @rgrondin ",
            "Don't use a realistic value here. \r\n\r\nWhile I know other data for these sets of endpoints is declared similar to this, I do think it's worth the investment to follow the pattern implemented for composite, in general throughout the module.\r\n\r\nWe should have clear, reusable, \"filler\" data for things that we're not concerned with (ie. the values in basically any of these fields), and demarcate them as being common, thus not the evaluated criteria. Then the tests, and model definitions, simply become the creation of some \"base case\" and copying it with relevant changes for special scenarios therein",
            "I'm thinking of [this file](https://github.aexp.com/amex-eng/m1-msl/blob/cd295e5ef020f1dc993a5a1239ebba8695ff71e5/backend-service-clients/messaging-v2-service-client/chat-service-client/src/test/java/com/americanexpress/mobileone/bsc/chat/test/support/models/conversation/api/FakeApiCommonValues.kt) in specific, which if you look at this the [`fakeApiCardmemberId`](https://github.aexp.com/amex-eng/m1-msl/blob/cd295e5ef020f1dc993a5a1239ebba8695ff71e5/backend-service-clients/messaging-v2-service-client/chat-service-client/src/test/java/com/americanexpress/mobileone/bsc/chat/test/support/models/conversation/api/FakeApiCommonValues.kt#L36) in your IDE, you'll see it has 16 usages (which is great, 16 spots we can be certain that the cardmemberId should match the sane defaults we are repeatedly using for testing)\r\n\r\nAn example of the sub-case copying described above can be found in the [models for relative vs. absolute expiry](https://github.aexp.com/amex-eng/m1-msl/blob/cd295e5ef020f1dc993a5a1239ebba8695ff71e5/backend-service-clients/messaging-v2-service-client/chat-service-client/src/test/java/com/americanexpress/mobileone/bsc/chat/test/support/models/conversation/api/messages/composite/FakeApiCompositeMessage.kt#L105-L118). Here we want to test status badges mutation during mapping, and having an expired message is absolutely a critical boundary to test against. Aside from this test though, all other cases we want some non-expired message always, hence the base case should be the non-expired message.",
            "Ahh I see, makes perfect sense, nice work!"
        ]
    },
    {
        "40759": [
            "Nit/Out of scope:\r\n\r\nIn my opinion, this is a super dangerous pattern. Specifically, a not-null object of all null fields has indeterminate serialization results. Some serializers will null the whole object, and exclude it entirely (as JSON spec indicates you ought to do), while others will retain an empty object, with similarly indeterminate fields (all as null, or none and simply empty object)",
            "Nit/out of scope:\r\n\r\nCan we update model with a default property? Could make code cleaner.",
            "This function is a bit oddly named/situated, would personally probably do something like this instead. Not huge, but wanted to leave input\r\n\r\n```suggestion\r\ninternal fun CustomerOverview.withBottomTab(bottomTabProduct: CustomerOverview.BottomTabProduct) =\r\n    copy(bottomTabProduct = bottomTabProduct)\r\n```",
            "Awesome, yeah totally out of scope but glad to hear"
        ]
    },
    {
        "40415": [
            "Can you migrate this to `PolymorphicEnumeratedFactory`? I'm trying to do so every time I add a type to one that's using this old approach",
            "Same here, can you update to `PolymorphicEnumeratedFactory`",
            "Same `PolymorphicEnumeratedFactory` comment",
            "This could be simplified via [`PolymorphicEnumeratedFactory`](https://github.aexp.com/amex-eng/m1-msl/blob/main/backend-service-clients/bsc-common/src/main/java/com/americanexpress/mobileone/bsc/common/moshi/adapters/polymorphic/PolymorphicEnumeratedFactory.kt).\r\n\r\nThis requires two things:\r\n1. Adding the [`Enumerated`](https://github.aexp.com/amex-eng/m1-msl/blob/main/backend-service-clients/bsc-common/src/main/java/com/americanexpress/mobileone/bsc/common/moshi/adapters/polymorphic/Enumerated.kt) interface to the base type. \r\n2. Adding an `enum` which is declared as the [`Enumerator`](https://github.aexp.com/amex-eng/m1-msl/blob/05a8f8a13e76473364613c10f40715554ca6f587/backend-service-clients/bsc-common/src/main/java/com/americanexpress/mobileone/bsc/common/moshi/adapters/polymorphic/PolymorphicEnumerator.kt#L5) of the supertype, with each `enum` value referring to its subtypes' class reference.\r\n\r\nFor some example usages, you can look at the below:\r\n* [Reference adapter](https://github.aexp.com/amex-eng/m1-msl/blob/main/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/adapters/CompositeMessageComponentAdapter.kt)\r\n* [Reference enumerated supertype](https://github.aexp.com/amex-eng/m1-msl/blob/main/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/models/api/message/attachment/screens/components/ApiComponent.kt#L12)\r\n* [Reference enumerator](https://github.aexp.com/amex-eng/m1-msl/blob/main/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/models/api/message/attachment/screens/components/ApiComponent.kt#L17-L29)",
            "I know we walked through this together, but I think this may be better expressed as the below. \r\n\r\nThere's really only one reason, which is compile-time errors protecting us from potential hiccups when we go to extend this type. Currently,  if we were to add a new type, but never actually serialize the type, we will risk errors getting to clients (in test environment, but still). This is because the tests will pass and all will seem okay if we were to add a new type, but hit a scenario where this `value as? ...` were to be `null`. While this might seem edge casey, we can actually write all the code and have it be fully functional, but if we don't have it in serialized payloads, we'll never know that it will actually throw an exception here.\r\n\r\nWe resolve this via the below updates:\r\n\r\n```suggestion\r\n    fun fromJson(value: ClientSelectable): ClientSelectable.Single = when (value) {\r\n        is ClientSelectable.Single -> value\r\n    }\r\n\r\n```",
            "Same as client explaination",
            "I think we can actually eek out a decent amount of re-use here, without doing anything too flagrant.\r\n\r\nGiven these are faked values, and we're just reconstructing these same resulting classes again, I don't see any reason why we should make 2 places to update instead of 1. Would ask @rgrondin for a tiny little sanity check here though.\r\n\r\n```suggestion\r\nval fakeClientProductSelectorComponent: ClientSelectorComponent = ClientSelectorComponent(\r\n    id = fakeClientProductSelectorComponentId,\r\n    scope = fakeClientScope,\r\n    selector = (fakeClientDropdownSelectorComponent.selector as ClientSelectorComponent.Selector.Single).copy(\r\n        single = ClientSelectorComponent.Selector.Single.PreviewSelection(\r\n            title = fakeClientSelectorTitle,\r\n            previewSelection = ClientSelectorComponent.Selector.Single.PreviewSelection.PreviewSelection(\r\n                button = fakeClientSelectorButton,\r\n                description = fakeClientSelectorDescription,\r\n                header = fakeClientSelectorHeader,\r\n                placeholderIcon = fakeClientIconValueComponent.iconValue\r\n            ),\r\n            values = NonEmptyList.of(\r\n                ClientProduct(\r\n                    value = fakeClientEnumeratedValue,\r\n                    label = fakeClientLabel,\r\n                    annotation = fakeClientSelectorAnnotation,\r\n                    url = fakeClientCardArtUrl\r\n                )\r\n```"
        ]
    },
    {
        "40210": [
            "We could and should enum this for sure"
        ]
    },
    {
        "39845": [
            "Generalizable easily via an interface, this is needed as if we don't, due to how companion objects are resolved, we'll get errors on first attempt to create the processor.\r\n\r\n> [Companion object resolution](https://kotlinlang.org/docs/object-declarations.html#behavior-difference-between-object-declarations-and-expressions)",
            "Did not change anything below, just indentation to hide the `impl` while allowing the companion to delegate to it  without exposing to whole package.",
            "This does, as we get a nullable proxy ref from `yttYamlData`, though to be clear, I don't know this ytt labels loading stuff well at all, this was more of a 'get it working' approach",
            "Yeah definitely the approach long term is quite a bit \"untangling\", my intention here was a minimal change set which resulted in no more `@Inject`,  `@Bean`, `@Configuration`, `@Named`, `@Singleton`, and `@Provides`. These can also fairly trivially be migrated to be hot-reloaded using the approach I've shown, as we can using `get() = ...` to handle this (or if we absolutely needed for some reason, a `MutableStateFlow`)",
            "This was mostly for consistency and ease of use. This makes it a single-function call to instantiate both for `main` and for `test`, whether you want the `Api` for a real backend client  or a `mockServer`.\r\n\r\nSee test file where this is leveraged [here](https://github.aexp.com/amex-eng/m1-msl/pull/39845/files#diff-2129c447c0c066a0a681fa798825706dd0aa050594c44f082f872b3bb2928457R12-R19)",
            "This interface could realistically be removed, though honestly it seems like it's overdue, but maybe a seperate set of changes.\r\n\r\nFeels like we should likely have a few of the common attributes used across all components, across features, and backends provided in an inheritable form. Could make things simpler.\r\n\r\nOne example is `AppClientMetaData` being defined as, which we could provide an interface for, which would implement it like:\r\n```kotlin\r\nval appClientMetaData: AppClientMetaData\r\n  get() = checkNotNull(\r\n    RequestContextHolder.getRequestAttributes()?.getAttribute(\r\n      APP_CLIENT_METADATA,\r\n      SCOPE_REQUEST\r\n    ) as AppClientMetaData?\r\n)\r\n```",
            "There's a name clash between the object `AppClientMetaDataHolder` and the interface `AppClientMetaDataHolder` \ud83d\ude22 \r\n\r\nI wanted this to implement the interface specifically, as I wanted it to be provideable without the user having to know about the semantics of resolving dynamically. Inside the course of any request it should be constant (in fact you wrote the code to guarantee that I think), so thinking of it and seeing it as `AppClientMetaDataHolder.appClientMetaData` seemed correct to me.\r\n\r\nThe name `AppClientMetaDataHolderAbstraction` is just an import alias, see above this line where we do:\r\n```kotlin\r\nimport com.americanexpress.intlmobl.app.servicerequest.AppClientMetaDataHolder as AppClientMetaDataHolderAbstraction\r\n```",
            "I\u2019ve actually been tinkering with an alternative which I think should work, effectively leaning on a dynamically resolved delegate, in effect leaning on request context. I\u2019ll be pushing it once I close a few Hudson team things and get it to pass tests",
            "Yup, kind of proud of that, it does work as expected, that I'm fairly confident in",
            "If we do need more, it's trivial to add via the above approach (ie. just have subclasses and one per, given they'd have to be different endpoints anyways for them to make sense). There's a ton of flexibility, but I'm working on a non-inheritable approach for companion objects using explicit delagtors, in the works though",
            "Provider ultimately doesn't do much except bind us to Java code, at absolute most I think using `getValue()` and `provideDelegate()` make the most sense. Ideally we'd be able to cut out all references to all injection libraries is my goal, to be explicit.",
            "Yeah I do agree here, I think it's too clever. I do have a bit of a solution for it that I'm toying with now. Regardless, I think walking back the cleverness is very feasible realistically"
        ]
    },
    {
        "39650": [
            "Yes it should, Moshi sees strings as `CharSequence`, and buffer IO is done via char stream, so shouldn't cause hiccups realistically",
            "Yeah, Or just `Format`, as we are inside the `Input` class already, so it will read `Input.InputFormat` \r\n\r\nThis change would be:\r\n```suggestion\r\n        sealed class Format(val type: Type) {\r\n```",
            "Love it"
        ]
    },
    {
        "39627": [
            "Or, even better, could do companion object inside the interface, delegated to lazy initialized concrete instance (which would be the corollary to the `INSTANCE`. Then you simply point at the interface like it's a singleton object, and you'll receive the lazy instance (which won't be created until it's first touched by an incoming reference)"
        ]
    },
    {
        "39603": [
            "Curiosity (and potential lookout): \r\n\r\nWas this breaking tests with the prior value? While having somewhat realistic values is potentially good, it's also potentially a risk for creating fragility if the tests are too granular, and test data too \"realistic\". I would try to step back the data a bit, and instead of realism target boundary conditions personally. That way, when the tests fail, they are telling us we've violated/moved a boundary, which is a good time to examine tests.",
            "If we do need this value in multiple places, can it be extracted and reused?",
            "`60` here vs. `20`\r\n\r\nIt's unclear personally what is causing this need. Regardless of that, these, assuming we don't test for anything other than consistency (ie. API gives us `n`, we produce `n` in client models), I think we should only have a single literal value defined for these attributes",
            "Can we use [Kotlin collections](https://kotlinlang.org/docs/collections-overview.html#collection) associations here? Idiomatic kotlin which is nice, and very flexible should needs arise. I'm thinking something like this:\r\n\r\n```suggestion\r\n    internal fun fetchRecentLineModificationDataForCreditLimit(\r\n        responseList: Collection<ReadAccountLimitsV3ClientResponse>\r\n    ) = responseList.associateBy { it.accountToken }\r\n        .mapValues { it.value.limits.extractRecentLineModification(LimitType.CREDIT) }\r\n```\r\n\r\n> [associateBy](https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.sequences/associate-by.html) referenece docs",
            "Borderline-nit:\r\nPersonally, I find `runIf` to be an odd control flow, and given we have `takeIf` and `takeUnless` as first-class stdlib in Kotlin, I normally prefer those personally.\r\n\r\nThis could look instead like below:\r\n```suggestion\r\n            cardList.toReadAccountLimitRequests().takeUnless { it.isEmpty() }?.let {\r\n                accountLimitsClient.readAccountLimitsV3(appClientMetaData.toAccountLimitsRequestContext(), it)\r\n                    .map { normalizer.fetchRecentLineModificationDataForCreditLimit(it) }\r\n                    .getOrElse { emptyMap() }\r\n            } ?: emptyMap()\r\n```",
            "Definitely a nit from me, but also in general I think a preference towards single-parameter functions with Kotlin lambda's passed explicitly is a very visible, consistent feature of the language. \r\n\r\nWe read blocks of line-indent carried code (_like below_) almost automatically. It's not a functional concern so much as a developer ease-of-use thought. Kotlin style guides show preference for it, and while it doesn't explicitly recommend against multi-lambda parameter usage, I think realistically it's a much more \"java-esque\" approach. [Kotlin Coding Conventions link for reference](https://kotlinlang.org/docs/coding-conventions.html#lambdas)\r\n\r\n```kotlin\r\nval x = myList\r\n  .map { }\r\n  . filter { }\r\n  .reduce { }\r\n  .mapTo(...) { } ?: emptyList()\r\n```",
            "I honestly just pulled spirit from Kotlin Coding convention, there's explicit scenarios for \"[Execute if not null](https://kotlinlang.org/docs/idioms.html#execute-if-not-null)\" and  \"[Map nullable if not null](https://kotlinlang.org/docs/idioms.html#map-nullable-value-if-not-null)\"\r\n\r\nThe real upside is not having to mentally parse the assignment statement, and were this not in a lambda body for `async`, my suggestion is an expression body syntax (style guide's explicit preference) whereas the current approach cannot, and must use explicit control flows to `return` ",
            "Neither of these is huge, but yeah, would definitely encourage, I feel like their usage is pretty widespread through our code.",
            "[Reference implementation follows this pattern in the processor as well](https://github.aexp.com/amex-eng/m1-msl/blob/0888972e9b9f910ba03840735c3429558bb3fa3b/features/reference-implementation/src/main/java/com/americanexpress/mobileone/referenceimplementation/ReferenceImplementationProcessor.kt#L40-L53), just so you can see another instance"
        ]
    },
    {
        "39580": [
            "Permitted lists was breaking during attempting to resolve button partial statelessness (ie. navigation vs. decision), I don't know if it was resolvable but this is cleaner imo",
            "Made whole button stateless, don't love love it, but I don't really know how to avoid honestly",
            "Earlier and more clear failure when it's getting fallback'd to text during API model ingestion",
            "This is simplified scaffolding, can discuss, but this is just making sure we have room to pass dynamic properties down the call chain during the mapping across screens, components, and subcomponents (for things like toggles).",
            "Tried to push creation of `CHAT` screen to appropriate (and \"higher/later\" level), we have no concept of `CHAT` screen in this API model",
            "This felt like a ton of logic to just toss into the mapper, which is already a 500 line file. Open to input though of course",
            "Neat trick here given we can leverage same serializers for this. We basically point Moshi at the existing (encapsulating object's) serializers, and since `Stateless` is just a marker interface with no properties, serialization is identical",
            "This holds true regardless of client version, to be explicit. This was intentional to not conditionally enforce based on client version",
            "Don't love this double creation, but, I think it's worth avoiding the duplication of the code for the component mapping.",
            "Is it market specific? Or even configurable? I didn't think of it as a feature flag personally, given it's not evident anywhere besides this mapping function I thought to keep it scoped minimally",
            "To be clear, making these changes now",
            "I actually did have something like that, though I chose not to as it ought to be unrecoverable, and this is private in file, such that all flows must go through the top-level `runCatching { ... }`.\r\n\r\nThe outcome adds some boilerplate, and I think ultimately we still need to `runCatching` to be fully safe as this is so complex, and we must ensure 100% resilience in all scenarios"
        ]
    },
    {
        "39574": [
            "If we have `UNKNOWN_FALLBACK_VALUE` does this need to be nullable?",
            "The way the JSON adapter is configured, we shouldn't even be able to get null, no?"
        ]
    },
    {
        "39490": [
            "While this is international english copy, do we want to link to US page still?"
        ]
    },
    {
        "39406": [
            "We're using `runCatching` for the sole entry into this flow, as we have some requirements around resilenciency. \r\n\r\nThere's no \"handleable error\" flow possible here, and we don't want to have to propagate up, rather throwing out is totally correct, and keeps it as simple as can be. "
        ]
    },
    {
        "38952": [
            "So toggle is kind of unique, as it contains an array of components. As a result we have to call the base API component to client component mapper, which results in us needing this expiry epoch as well as the request data for toggle"
        ]
    },
    {
        "38780": [
            "Nit nit: Given it's so mechanical, personally I'm a fan of an extension `val` on the type itself, like so:\r\n\r\n```suggestion\r\n    private val PointsTransferLabels.Screen.Fields.Field.isPartnerAccountNumber\r\n        get() = this is PointsTransferLabels.Screen.Fields.Field.Dynamic &&\r\n            type == Field.Type.PLACEHOLDER_TEXT_INPUT &&\r\n            restrictionName == PARTNER_ACCOUNT_NUMBER\r\n```",
            "Crazy nitty: The formatting on this tripped me up a bit, the newlines seemed a bit verbose and I definitely didn't flow through the code like I'd expect to. Personally I'd write it as below, given we comfortably fit on one line and it's not calling any complex functions or manipulations\r\n\r\n```suggestion\r\n        val partnerNumberMinLengthRestriction = restrictions\r\n            .find { it.name == PARTNER_ACCOUNT_NUMBER }?.restrictions?.find { it.name == MINIMUM_LENGTH }\r\n```",
            "Personally would externalize this probably, on a extension of `groups` probably, but not at all needed. Likely I'd approach many of the mechanical derivations inside this function the same way, with the goal of avoiding the added annotation for suppressing the long method warning"
        ]
    },
    {
        "38703": [
            "This is a simpler solution then creating some interface of type `Toggleable`, and assigning that to certain components. That causes some deserialization complexity, so I did this instead, though not opposed to either solution."
        ]
    },
    {
        "38647": [
            "I don't think we need to actually pass this in, given we're hardcoding the adapter type, this isn't actually doing anything. We could just update adapter call like below",
            "Simpler, without any `KType` (which wasn't doing anything meaningful anyways)\r\n```suggestion\r\n    private val adapter by lazy { moshi.adapter<ApiInputValidator>(ApiInputValidator::class.java) }\r\n```",
            "Same here, we don't need `elementType`, as we already know with certainty what the root class for the array contents will be",
            "Removing `elementType` is nice, because this is super unclear, but we can simply drop this parameter which is good. \r\n\r\nWe could simplify these 5 lines to a single, much clearer, line, [like this](https://github.aexp.com/amex-eng/m1-msl/compare/feature/M1-192081-validations-compatibility...feature/M1-192081-validations-compatibility-amichn?expand=1#diff-8d59fc958ff43b6361915484457b380925b38bdb9450ba195a928828eda333c3R17)",
            "Personal Pref: Don't love how the whole iteration is outside of the adapter class. Here isn't super impactful, but in general it feels like a pattern which exposes a lot to potentially the wrong parties.\r\n\r\nSomething instead may be thought of like \r\n> read all the JSON in `fromJson`, and when we have some JSON we know we need to handle using a special handler, lets jump to a function call for that\r\n\r\nI did something similar in my approach [here](https://github.aexp.com/amex-eng/m1-msl/compare/feature/M1-192081-validations-compatibility...feature/M1-192081-validations-compatibility-amichn?expand=1#diff-8d59fc958ff43b6361915484457b380925b38bdb9450ba195a928828eda333c3R36-R38) for reference",
            "We can't test this, and we (strictly) don't serialize API models for this flow. We'll never have to send a list of validations to a backend, so we should YAGNI until then, and should throw loudly when we attempt to use something that's not in scope.\r\n\r\n```suggestion\r\n    ) = error(\"Not implemented\")\r\n```"
        ]
    },
    {
        "38377": [
            "I really think we should leverage something like [`Enumerator`](https://github.aexp.com/amex-eng/m1-msl/blob/05a8f8a13e76473364613c10f40715554ca6f587/backend-service-clients/bsc-common/src/main/java/com/americanexpress/mobileone/bsc/common/moshi/adapters/polymorphic/PolymorphicEnumerator.kt#L5-L17) alongside [`Enumerated`](https://github.aexp.com/amex-eng/m1-msl/blob/05a8f8a13e76473364613c10f40715554ca6f587/backend-service-clients/bsc-common/src/main/java/com/americanexpress/mobileone/bsc/common/moshi/adapters/polymorphic/Enumerated.kt#L3-L12), it's been immensely valuable in ValGen via usage of [`PolymorphicEnumeratedFactory`](https://github.aexp.com/amex-eng/m1-msl/blob/c0047f8b42e2bed42e7898ca1cd3d3eaf79f04fe/backend-service-clients/bsc-common/src/main/java/com/americanexpress/mobileone/bsc/common/moshi/adapters/polymorphic/PolymorphicEnumeratedFactory.kt#L6).\r\n\r\nFor an example of usage, see [`ApiComponent`](https://github.aexp.com/amex-eng/m1-msl/blob/a05aeb918c6e3b3461d85efe38ef3791003c0402/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/models/api/message/attachment/screens/components/ApiComponent.kt#L12-L36)",
            "Do we want Jackson? We're going to hit some pretty big roadblocks realistically, would be in support of Moshi, though I know it's breaking with some patterns (though it's also inherently breaking with patterns, given we're also the SOR)",
            "Really wish we could leverage value class here, though again we'd need Moshi in order to do so. I think there's a lot of value in doing so personally",
            "What's so cool about `Enumerator` is that a class like this would **not** extend it, thus we'd know for certain it's not being discriminated on in type hierarchies.",
            "I'd commit to building it (quickly) if this is the only blocker"
        ]
    },
    {
        "38352": [
            "Actually specifically this is unsupported by specification. Per [IETF-3339 Appendix A](https://datatracker.ietf.org/doc/html/rfc3339#appendix-A) we can see that `full-date` doesn't have any support for any timezone information, which makes sense if you think about it.\r\n\r\nJDK Standard Library implementation reflects this as well in the [LocalDate documentation](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/time/LocalDate.html) , where it even says explicitly\r\n> This class does not store or represent a time or time-zone. Instead, it is a description of the date, as used for birthdays. It cannot represent an instant on the time-line without additional information such as an offset or time-zone."
        ]
    },
    {
        "38350": [
            "I have a change for this, I do believe it should be required per clients, but will confirm here",
            "<img width=\"665\" alt=\"image\" src=\"https://github.aexp.com/amex-eng/m1-msl/assets/17603/c8a7558e-3dbe-4201-83a1-124939277fb7\">\r\nRequired per AskAmex, updating SDUI now"
        ]
    },
    {
        "38328": [
            "Will update this in followup, going to update ref impl right now to show usage, will include there!",
            "Normally I'd be in favor of renaming since it seems like there's confusion, but I'm unsure here, since I'm intentionally keeping us very consistent with the Moshi nomenclature (intentionally so).\r\n\r\nSee below signatures, lifted directly from Moshi source:\r\n```kotlin\r\npublic static <T> PolymorphicJsonAdapterFactory<T> of(Class<T> baseType, String labelKey)\r\n\r\npublic PolymorphicJsonAdapterFactory<T> withSubtype(Class<? extends T> subtype, String label)\r\n```\r\n\r\nI'm okay personally with something like `discriminatorKey`, but just wanted to make sure the full picture was clear before proceding"
        ]
    },
    {
        "38089": [
            "Unsure how this occurred but definitely correct, updating",
            "Yeah, old one for validations untyped was, updating"
        ]
    },
    {
        "38028": [
            "Not needed any more per [this alignment](https://aexp-mobile-and-web.slack.com/archives/C05B0S4NY8J/p1732780843681519?thread_ts=1732740652.818209&cid=C05B0S4NY8J)"
        ]
    },
    {
        "38008": [
            "Because it can be sealed, so it ought to be, for tighter type closures",
            "The approach above does not allow for re-use, and is certainly a more constrained approach. We are registering 50+ adapters for this module, the approach of doing so inline is hugely unmaintainable ",
            "There is less adherence than I'd like to the naming standard, but definitely we should have `Factory` implementers identifying themselves as factories. While the code isn't perfect as is, we should still hope to follow best-practices as much as we can",
            "We manage these in [JsonAdapterUtil](https://github.aexp.com/amex-eng/m1-msl/blob/e91939e45e3d034f96565992864cdefd25b0c381/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/adapters/JsonAdapterUtil.kt#L19-L18) to be clear",
            "> **Status: failure** Runner: aexp-ubuntu-latest-medium Main Build Scan URL: https://gradle.aexp.com/s/ikxtmce2gaq5e\r\n\r\nThis was a regresion failure, repulling main and rerunning"
        ]
    },
    {
        "37997": [
            "I did try this but Moshi has a fit, I\u2019ll likely look into it in the future but clients are waiting on some of this stuff"
        ]
    },
    {
        "37988": [
            "Is this something we can enumerate @rgrondin ?",
            "Great minds lol"
        ]
    },
    {
        "37880": [
            "Updated",
            "Update"
        ]
    },
    {
        "37873": [
            "Will this always match the `$.taxIdInput.text.title` input field title? Just looking through and saw this so wanted to ask if there should be some enforcment of a semantic linkage here (or just a constant which is effectively resolved on some polymorphic basis). Would we ever want `id` to be `ITIN` while `title` is `SSN`?\r\n\r\nShould this be something more robust than a string? Seems like a limited enumerated set of national identification number formats, feel like it could be better expressed as a string potentially. \r\n\r\nThis may be out of scope of this pull request though, to be clear, just thoughts as I was reading through these examples",
            "Can we be consistent with naming? We have the encapsulating type `TaxIdScreen`, but we call this `TaxIDSource`. Personally I prefer the strict camel naming just for clarity, and given we're generally following that breaking seems bad here.\r\n\r\n```suggestion\r\n        data class TaxIdSource(\r\n```",
            "There's a ton ton ton of duplication here, can we leverage [Kotlin data classes `copy()` function](https://kotlinlang.org/docs/data-classes.html#copying) here to minimize the amount of code we have to maintain? ",
            "Seems like a lot of opportunity for inheritance here, any background on this? For example the `continueButtonText`, for some `ContinuableScreen` which is a child of some `Screen` (potentially empty, sealed, root node of hierarchy?)",
            "This makes perfect sense, thanks for all the changes, approving!"
        ]
    },
    {
        "37743": [
            "Yeah I ran into same hiccup with `entries` haha, regardless though like these changes, I've applied them locally",
            "Also really like this, and nice optimization as well!",
            "Leftover oops",
            "I've actually added 1 `of` function, just to support `vararg` based non-null initialization of `ApiInputValidationList` explicitly",
            "Definitely valid, I've cleaned this up now",
            "We definitely need this bound, as we need to be able to specify the type of each element. We have 3 meta-interfaces, `Required`, `Numeric`, and `Text`, and all validators currently implement one of them. This allows strongly typed array contents on the basis of the type of the `INPUT` we're willing to accept",
            "Definitely need to resolve the element type, again, because this is semantically super rich and significant",
            "Just applied this, really like this feedback, totally valid and correct esp the chained calls"
        ]
    },
    {
        "37727": [
            "Please add instead to [`JsonAdapterUtil.kt`](https://github.aexp.com/amex-eng/m1-msl/blob/main/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/adapters/JsonAdapterUtil.kt#L36-L45)",
            "Please add instead to [`JsonAdapterUtil.kt`](https://github.aexp.com/amex-eng/m1-msl/blob/main/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/adapters/JsonAdapterUtil.kt#L36-L45)",
            "Seeing now it's added, no need to also add to these, feel free to instead delete these since they're already in your delta",
            "Do want to get some clarity, I'm generally against being so concerned with what ultimately is a client-side concern. We are isolated from this concern, and I think it's reasonable to seek to stay as such. \r\n\r\nIdeally, if needed we could rename at serialization time",
            "Really would like to keep as it enforces the dynamic array typing (and parameterization by the `enumerated` e`type`). This can be used in a huge variety, and I is the most elegant, extensinsible, & maintainable implementation of such a construct I could come up with.\r\n\r\nThis enables effectively implementation of any item type, and requires some declared `value` at a minimum. This makes supporting various other formats, stylizations, and who knows what else quite easy. For example, doing a card selector, we could easily do so in this construct with minimal changes to add an `Enumeration` child implementation ",
            "Can we rename this to `Enumerated`? We're already in the scope of `Selector`, repeating it here doesn't add anything in my opinion.\r\n\r\nI've been super intentional basically everywhere following the pattern I'm recommending just to be clear, would really like to see :) ",
            "Another naming thing, would say, `Enumerated`, as we're already in scope of `ApiSelectorConstraint`",
            "Same naming here, `Enumerated`",
            "Also , to be very very explicit, we absolutely do not link `presentation` to `$.constraint.enumerated.values`'s `type`.\r\n\r\nThis `presentation` enum solely informs clients, we are inert on it, simply parsing and regurgitating. `$.constraint.enumerated.values`'s type is wildcarded to the encapsulating `$.constraint.enumerated`, and handled via `NonEmptyList` as a covariant generic child of `Enumeration`",
            "Agreed, though I was also thinking about potentially moving them onto components as a interface function declared in `{}AbstractComponent`, any thoughts on that as an uplift follow-up?",
            "Is it? I think there's a case for card design being a perfect fit, and that's next on the roadmap\r\n![image](https://github.aexp.com/amex-eng/m1-msl/assets/17603/29f4b1b2-fe1d-41c5-9f24-9497574599b5)\r\n",
            "Can we rename this to `type`? We're in the scope of a `SELECTOR`'s enumerated data, no need to restate\r\n\r\n```suggestion\r\n    enum class Type {\r\n```",
            "Should be internal\r\n\r\n```suggestion\r\ninternal sealed class ApiSelectorEnumeratedData(val type: SelectableType) {\r\n```",
            "We are in the scope of `API` + `SELECTOR`, so naming can reflect that (especially as it's nested classes we can leverage this with even more certainty).\r\n\r\nCould simplify naming to something like the below\r\n\r\n```suggestion\r\n        abstract val assistiveText: NotBlankString?\r\n        abstract val accessibility: ApiComponent.Accessibility\r\n        abstract val style: ApiFieldStyle\r\n        abstract val nullability: Nullability\r\n\r\n        enum class Type {\r\n            SINGLE\r\n        }\r\n\r\n        data class Single(\r\n            override val accessibility: ApiComponent.Accessibility,\r\n            @Json(name = \"assistive_text\")\r\n            override val assistiveText: NotBlankString? = null,\r\n            override val label: Label,\r\n            override val style: ApiFieldStyle,\r\n            override val nullability: Nullability,\r\n            val single: EnumeratedData\r\n```",
            "Can we remove this layer until we have a use case for federating single vs. multi eligible elements? Just to save some code , YAGNI, etc",
            "Can make this a sealed class to help make controlling `type` a bit more seamless\r\n\r\n```suggestion\r\nsealed class ApiSelectableElement(val type: Type) {\r\n```",
            "With update to `class` for `ApiSelectableElement` this would become\r\n\r\n```suggestion\r\n    data class LabeledValue(\r\n        override val value: NotBlankString,\r\n        val label: Label\r\n    ) : ApiSelectableElement(Type.LABELED)\r\n```",
            "Ideally this `Input.Single` specific data class would live inside the only user of it, something like this:\r\n\r\n```suggestion\r\n        }\r\n\r\n        data class Single(\r\n            override val accessibility: Accessibility,\r\n            @Json(name = \"assistive_text\")\r\n            override val assistiveText: NotBlankString? = null,\r\n            override val label: Label,\r\n            override val style: ApiFieldStyle,\r\n            override val nullability: Nullability,\r\n            val single: Data<ApiSelectableElement>\r\n        ) : Selector<ApiSelectableElement>(Type.SINGLE) {\r\n            data class Data<T : ApiSelectableElement>(\r\n                override val values: NonEmptyList<T>,\r\n            ) : AbstractData<T>(Type.Single)\r\n        }\r\n```",
            "There's also another opportunity here I didn't touch on, that I think would be a meaningful improvement, which is retaining the generic bound `<T : ApiSelectableElement>` for single. Right now we're down-casting it, and then making it covariant via `out` , but that's going to lose us some control over the types, and remove the compiler's ability to guarantably inform us of the type of the elements.\r\n\r\nWe could keep these advantages pretty easily, by doing something like below:\r\n```suggestion\r\n        data class Single<T : ApiSelectableElement>(\r\n            override val accessibility: Accessibility,\r\n            @Json(name = \"assistive_text\")\r\n            override val assistiveText: NotBlankString? = null,\r\n            override val label: Label,\r\n            override val style: ApiFieldStyle,\r\n            override val nullability: Nullability,\r\n            val single: Data.Single<T>\r\n        ) : Selector<T>(Type.SINGLE)\r\n```"
        ]
    },
    {
        "37724": [
            "So I did actually intentionally do this, my thinking was `toClient` was always a mapping of one API property to one Client property. This conversion was, in my mind, the `to`, as I thought of it as a bijective mapping. That is, it is a true 1-to-1. \r\n\r\nThe change in nomenclature was supposed to capture that the mapping for these validations wasn't bijective, but subjective, as we are creating one or more elements in the codomain based off each element in the domain"
        ]
    },
    {
        "37696": [
            "This was created as order of adapter registration matters, and it was quickly becoming cumbersome, so I wanted to limit the misuse potential.",
            "No functionality change here, just delegation to `JsonAdapterUtil`",
            "This is needed, as we need to support deserialization regardless of the type at the use-site. This is due to the fact that initially, we will simply see this use-site type as `ApiInputValidator`, as we're in the surrounding scope, and haven't resolved the generic `S` for the implementation of the abstraction `sealed class Input<out S : ApiInputValidator>`. This means our `S` is still wildcard-typed, so we must be able to deserialize `ApiInputValidator` (though we shouldn't navigate it, we simply need the adapter as data class comprehension requires this). Then, we will resolve the outer type of the `Input`, to either `Currency` or `Plaintext`, at which point the implementation of `ApiInputValidator` will also be resolved as well, to either the `ApiInputValidator.Text` or `ApiInputValidator.Numeric` abstractions, which will then finally have fully concrete leaf nodes which can be polymorphically resolved, as see in the top two implementations.",
            "This handles defaulting elements of the `validations` array to type `REGEX`. This is required as currently backend sends these with no `type` attribute, though we know it's always implicitly of type `REGEX`",
            "These implementations are complete, and will be added once the subsequent pull request is opened",
            "`patterns` is a pure regex representation of the validations, which we need to approximate in order to maintain compatibility.",
            "These are 'attributes' of `ApiInputValidators`, specifically used to guarantee the strongly typed safety of the elements of the `validations` arrays, dynamically, purely based off the resolved `input` type.",
            "Reifications to avoid generic erasure",
            "Here we need to select only the `Text` types, as we're building the `patterns` array",
            "It's not to do with eligibility, but rather ability to be converted into a regex representation",
            "There's no need to filter to type `Text`, as this is for `Plaintext`, which we know all `validations` can be converted into a `patterns` representation",
            "> Would two instances of `Required` with a different value of `errorMessage` be considered equal given the equality function only asserts type? Same comment for the other types below\r\n\r\nYes, as we will enforce uniqueness on this array, which will leverage the equality test for elements. This _(in my current \"vision\")_ should most definitely fail, as it's ambiguous as to which one is actually the message that should be showed to a cardmember.",
            "> Could you please clarify why equals/hashCode need to be overridden here and below for these data classes?\r\n\r\nThe equality of various types will depend on specific type semantics. Ie. we cannot support meaningfully (and consistently behavior-wise) multiple `Required`, but multiple `Regex` makes perfect sense. \r\n\r\nThese are simply API models, which will only be used at deserialization time, and limited to this internal package scope, so while these may seem very bespoke, it's entirely about ensuring validity of the array contents at ingestion time.",
            "Ooo Oops, yeah no reason \ud83d\ude05  will remove",
            "This was actually only needed in the client model serialization as a result of the `out` which I was able to remove, so nothing here!\r\n\r\nChange is [here](https://github.aexp.com/amex-eng/m1-msl/pull/37724/files#diff-87a0ce4034c12945dec6cfe24e9a4e1f45c840904ad44c1809b6858887ca68ffR12) for reference",
            "Applied this change [here](https://github.aexp.com/amex-eng/m1-msl/pull/37724/files#diff-7cef74dd089b35f56c3c74e618c86b8ffc822aa673114046f47bbe56eae9eda8)!"
        ]
    },
    {
        "37693": [
            "Do we mean for this to be this return type? Unsure about how this existing code works, but seems like a pretty confusing name clash if it is intentional. \r\n\r\n```suggestion\r\n    private fun List<ChangeEmailResponse.AccountUpdateStatus>.getUpdateResponseLabels(): Outcome {\r\n```"
        ]
    },
    {
        "37666": [
            "```suggestion\r\nval updateCustomerProfileRequestEmailOnly = updateCustomerProfileRequest.copy(\r\n    contactDetails = UpdateCustomerProfileApiRequest.ContactDetails(\r\n        emailDetails = updateCustomerProfileRequest.contactDetails.emailDetails,\r\n        phoneDetails = null,\r\n        addressDetails = null\r\n    ))\r\n\r\n```",
            "Nit (ish): I'm personally a big fan of defaulting nullable parameters to `null` in data class constructors, makes it easy to understand they are truly auxillary",
            "Nit: \r\nCould keep the `mapNotNull` and then just do the new elvis behavior, I think that's cleaner and more `stdlib` adherent than the call of `toNonEmptyList` personally.\r\nI also like that it's the first thing you read, so you have the mental context when evaluating the code if you're reading through this bit",
            "Feels like this list (and above lists) could be simplified a lot by usage of `copy`, but it's not the end of the world , just a maintainability thing",
            "More duplications, won't go through rest of file but yeah, seems like it's worth cleaning up imo",
            "Can't check out locally because working on delta that'll be a headache to stash and restage, but can we do this here? \r\n```suggestion\r\n            assertThrows<MobileClientException> {\r\n                subject.createAccountUpdateStatusV2(\r\n                    profileEmailResponse = fourAccountsPartialFailureV2.copy(propagationAccounts = emptyList())\r\n                )\r\n            }\r\n```",
            "Also this double throws? Bit confused idk how lol",
            "Definitely valid, though I think the model reuse (assuming this model will serve only as a \"I have no phone or address details\" tester) would be a positive thing, especially if these null are driving a rich set of behaviors.",
            "Would also say, can we imply some typing for this? On the presence of keys? Even if backend doesn't specify, we _could_ infer some MSL internal types, one of which may be the concrete implementation with the minimal info state. I'm just trying to make sure we don't support invalid data-states, as all too often that's the root of lots of evil.",
            "Makes sense on the change to mapNotNull, and don't worry about C+P lol just was throw by highlighting is all"
        ]
    },
    {
        "37642": [
            "No need to suppress this, we should have our code be adherent to [Kotlin's defined coding conventions](https://kotlinlang.org/docs/coding-conventions.html)",
            "If you need help doing so I can assist",
            "Ideally any comments would have a link to a ticket where we can see the validity of said comment.\r\n\r\nFor an example see [this code snippet](https://github.aexp.com/amex-eng/m1-msl/blob/ecd0f3d4c07041cd394c72ccb489ee938498cce8/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/mappers/composite/CompositeMessageMapper.kt#L262-L267)",
            "Really feel like `@JvmInline` annotations and  `value` classes would help here, but I know the project is moving fast.\r\n\r\nEspecially as we want to keep these strings in the proper respective sections, adding these types could help solve a whole class of bugs.",
            "Another supression"
        ]
    },
    {
        "37601": [
            "Note that we can do this in BSC layer, as we have Moshi factories which will inspect `KType` and thus clear the erased generic issue which prevents Jackson from succeeding"
        ]
    },
    {
        "37562": [
            "We use this object 7 times here, can we extract and reuse?"
        ]
    },
    {
        "37556": [
            "If we have a `V2` request I think we should have a `V1` request personally",
            "Is this truly going to be a map indefinitely? Personally pretty against such unconstrained data models if at all possible",
            "Would prefer this block in the caller function, so we can see that in the case of legacy we're doing one thing, while the updated is doing another action. Currently the `selectedProfileProduct` is nullable, but I suspect that's something that may get solved if we take the below conditional approach (if it's presence depends on the type of the incoming request)\r\n\r\n```kotlin\r\nwhen (request) {\r\n  is LinkAccountRequest.Legacy -> request.toClientRequest(accountToken, selectedProfileProduct)\r\n  is LinkAccountRequest.V2 -> request.toClientRequest(...)\r\n```\r\n```",
            "Personally, also, I'm not a huge fan of `V\\d+` as naming convention, as it doesn't really have any explicit meaning if you don't know the API. Much rather have the semantic difference (`member` vs `partner` looks to map onto this `v1` to `v2` change), which is how people will talk about it in general discussions, and will give readers insight into what is actually the difference",
            "Super questionable personally, loose maps are a pretty scary thing, especially if there are those requirements. I know you know, but obviously MSL can't assert anything worthwhile via this map, pushing failure (and failure handling/observability) downstream onto clients.\r\n\r\n@rgrondin @vdharma would be curious on some more experienced folks thoughts here. I suspect this has to go into release, but on a \"strategy\" level, this seems like a fairly flagrant red-flag (speaking from experience in chat, this exact type of approach was a huge source of the tech debt we've largely resolved).",
            "Super nit: Prefer the `fake` as a prefix, as it will largely guess correctly in IntellIj with autocomplete",
            "Better to follow a single pattern though, and seeing postfix here, so I'd postfix personally",
            "Given it's a `data` class we don't need explicit annotations is my understanding.\r\n\r\n[See reference implementation for examples of \"naked\" data classes](https://github.aexp.com/amex-eng/m1-msl/blob/4f978b04635e44b907f8acd48e41e10420535c7e/features/reference-implementation/src/main/java/com/americanexpress/mobileone/referenceimplementation/ReferenceImplementationModels.kt#L11-L34)",
            "If it was me, what I'd do is understand the true implicit typing in the underlying backend response.\r\n\r\nThat is, what properties, when present, will always imply the presence of whatever other properties? I'd stratify based off of this, and develop disparate data classes, with the aim of composing them. Ideally this wouldn't be explicitly tied to markets, even if it's determined by the market effectively, as we want flexibility to change each markets concrete implementation.\r\n\r\nI'd then create interfaces to outline abstractions containing the created data classes, and concretize them at leafs. \r\n\r\n"
        ]
    },
    {
        "37532": [
            "Yeah sorry meant to close, closing now"
        ]
    },
    {
        "37503": [
            "Can we expose each of these `BenefitResponse.Filter`'s as actual `val`'s? This would allow re-use, which will not only save time/code, but also make testing less error prone as we'd have a single source for these constant values.\r\n\r\nWe duplicate this code already in `test/.../BenefitsTestData.kt`, and even looks like we have a mis-alignment. If these values matter, I'd assume one is wrong currently? If they don't matter, we shouldn't care, we should only care about the failure condition we're examining.",
            "A good example of what I'm discussing is [visibile here](https://github.aexp.com/amex-eng/m1-msl/blob/c6196f33d542a50c63cbe36e1adf8f5ae44004ef/backend-service-clients/messaging-v2-service-client/chat-service-client/src/test/java/com/americanexpress/mobileone/bsc/chat/test/support/models/conversation/api/FakeApiCommonValues.kt#L32-L102) for our API model fakes, and [here](https://github.aexp.com/amex-eng/m1-msl/blob/c6196f33d542a50c63cbe36e1adf8f5ae44004ef/backend-service-clients/messaging-v2-service-client/chat-service-client/src/testFixtures/java/com/americanexpress/mobileone/bsc/chat/conversation/client/conversation/FakeClientCommonValues.kt#L31-L97) for our client model fakes.",
            "Nit/Personal Pref: \r\nI personally like the more \"kotlin-esque\" approach of something like below, though this is entirely personal pref:\r\n```suggestion\r\n        fun buildFilters(categoryMapping: Map<String, String>, categories: List<String>) = repositionEnroll(categories)\r\n        .map { categoryMapping[it]?.let { label -> BenefitResponse.Filter(it, label) } }\r\n\r\n```"
        ]
    },
    {
        "37436": [
            "Removing type from here doesn't increase our risk, but does increase our resilience, we should definitely do so, then this is easy peasy",
            "All we have to do is make sure we don't fail on `type` existing, and we should be forward compatible, as when we start discriminating we can avoid failures due to missing `regex` (for other subttypes)",
            "I guess we need them at serialization time actually nevermind"
        ]
    },
    {
        "37427": [
            "We override this for Regex, but for other types we need exclusioniary behavior, as what do we do when we get 2 maximums? "
        ]
    },
    {
        "37131": [
            "Do we want to leak the API response error codes to client layer though? I'd think we'd not, though I do agree, this is needless duplication especially if we aren't doing anything different based on these errors.",
            "A lot of this error handling seems superfluous, and especially as we're actually creating the explicit 'error' we are using effectively as a flag to clients that they need to enter this new flow.\r\n\r\nSeems like a lot of changes to support a functionally fairly straightforward requirement, though I'm unsure I'm getting the full scope from the tickets. Regardless of that, it feels like we're misleading clients here, and will likely run into issues at some point, as we're creating some `ERROR` response with these changes, when what we mean to communicate is that we have no eligible/active payment instruments available ([link to code for conditional](https://github.aexp.com/amex-eng/m1-msl/blob/41ea7e72cf3f68c42dd612a10cb328d836b1056e/backend-service-clients/payments/payments-ebim-client/src/main/kotlin/com/americanexpress/mobileone/bsc/payments/ebim/instruments/PaymentInstrumentsMapper.kt#L60-L66))"
        ]
    },
    {
        "37115": [
            "**[See here](https://aexp-mobile-and-web.slack.com/archives/C024JLYLSF9/p1730210102873649)**"
        ]
    },
    {
        "36915": [
            "I think I can help here actually, going to reach out on slack!"
        ]
    },
    {
        "36856": [
            "Are we wanting to hardcode this",
            "This whole model seems to me to be compositional in nature, effectively polymorphic though discriminated by the present attributes, not an explicit key. \r\n\r\nCould we use [`NamePolymorphicAdapterFactory`](https://github.aexp.com/amex-eng/m1-msl/blob/ec632576b645969d5470db5edee4cb8184b35cfe/common/msl-common/src/main/java/com/americanexpress/mobileone/model/moshi/adapters/NamePolymorphicAdapterFactory.kt#L25-L135) to control this?\r\n\r\nIt's very very hard to know what the response will look like based on this definition, as all but 4 attributes are nullable, and three of the `Int`s I see being set to `0` all over, seemingly to represent `null`?\r\n\r\nLet me know if you'd like a hand trying to wrangle this, more than happy to help!",
            "Certainly, let me reach out over slack, if nothing else it's a good capability to know exists!"
        ]
    },
    {
        "36782": [
            "Could we put the reusable paths in a shared file? Maybe a sibling package of `v2`, which is named `common` or `shared`, and a file where we provide these values? May also be worth to remove the version prefix from these, and instead have the version prefix as a `private const val` in the controllers themselves. Would allow a very clear representation of what was reused and what wasn't",
            "Look into using this [`stub`](https://github.aexp.com/amex-eng/m1-msl/blob/d51eb321b8f7198087ca692bd712b7235dbc73bd/testing/test-support/common-test-support/src/main/java/com/americanexpress/mobileone/test/support/base/TestSupportUtil.kt#L149) method, it will avoid having to do the above. If it was me, I'd likely short-circuit the map, from what I can see it's most all 1 call being made against the fake processor, so we can just say echo back input. \r\n\r\nSomething like this:\r\n```suggestion\r\ninternal class ReactiveLineIncreaseProcessorV2Fake(\r\n    private val summaryStubs: Outcome<ErrorResponse, SummaryResponseV2>\r\n) : ReactiveLineIncreaseProcessorV2 by stub() {\r\n   override fun summaryV2(\r\n        accountToken: AccountToken,\r\n        cardPaymentType: CardPaymentTypeV2,\r\n        lineOfBusinessType: LineOfBusinessTypeV2?\r\n    ): Outcome<ErrorResponse, SummaryResponseV2> = run { summaryStub }\r\n}\r\n```",
            "A bit of background on the `stub` method [available here](https://github.aexp.com/pages/amex-eng/amexway/docs/paved-roads/jvm/testing/unit-test-guide/prefer-real-impl-or-fake-impl-over-mocking)",
            "Yeah I kind of assumed they would be, which is why I think it's good to factor the `/v[0-9]` prefix out from the strings, keep them normalized as `/(resource)` and then we can reuse and make sure our `v2` is actually the same path as `v1`, just incremented",
            "Stubs work for all methods, it's quite a cool solution. You are able to only override what you care about, everything else is handled reflectively, it's neat.",
            "I'm mostly trying to reduce the additional complexity added by the test suite, don't love the data class addition (though I do understand the reasoning), which is why i'm trying to avoid it.",
            "[Here's the common root is factored out](https://github.aexp.com/amex-eng/m1-msl/blob/61aa3d52e04a8b8c9821aa60d8688756d8fd4cc2/features/search/src/main/java/com/americanexpress/mobileone/search/v1/controller/SearchController.kt#L41), let me know if still unclear",
            "Love this update! Only tiny nit (totally up to you) would be `private` instead of `internal`\r\n\r\n```suggestion\r\n    private data class SummaryArguments(\r\n        val accountToken: AccountToken,\r\n        val cardPaymentType: CardPaymentTypeV2,\r\n        val lineOfBusinessType: LineOfBusinessTypeV2?\r\n    )\r\n\r\n```"
        ]
    },
    {
        "36763": [
            "Really big fan of extracting common test values like this, calling it some generic name, and referring to it everywhere where it's not the boundary being tested. For example, I'd call this `FAKE_DECIMAL_DOLLAR_AMOUNT`, and replace it anywhere we have a throwaway amount that's populated.  Makes test upkeep enormously easier.",
            "Ditto here.\r\n\r\nOne good way of thinking about this is as follows:\r\n* For some data, we care a lot about its value, but for others we just care about the shape/type\r\n  * One is \"semantically rich\" from our point of view, the other \"semantically poor\"\r\n  * Specifically, we have enough information to drive behavior from the rich cohort, and insufficient for the poor cohort\r\n* Given this, when faking, we should be choosing to segment our data models along those two lines, semantic richness and poorness\r\n  * For rich, choosing meaningful values should be easy, as we know what they mean. We can choose to make sane defaults, especially for data classes, and copy them around changing the field at use-site (where needed).\r\n  * For poor, we should declare a single, reusable, common value, which ideally shouldn't ever get replaced in the test suite.\r\n\r\nA test failure due to a semantically poor attribute doesn't mean anything except we have fragile tests!\r\n\r\nJust figured I'd drop this as I thought about it while looking at this very complex structure..\r\n\r\n[Here's an example of the semantically poor attribute files](https://github.aexp.com/amex-eng/m1-msl/blob/c5f27f5455d12a9a54c4fd4399909b3e53c079f8/backend-service-clients/messaging-v2-service-client/chat-service-client/src/test/java/com/americanexpress/mobileone/bsc/chat/test/support/models/conversation/api/FakeApiCommonValues.kt#L32-L102)\r\n\r\n[And this is usage of said fakes, in a test suite](https://github.aexp.com/amex-eng/m1-msl/blob/5d121de6870cc27463a695ad09751bc58b8cb4a0/backend-service-clients/messaging-v2-service-client/chat-service-client/src/test/java/com/americanexpress/mobileone/bsc/chat/conversation/mappers/ConversationResponseMapperTest.kt#L36-L61)"
        ]
    },
    {
        "36560": [
            "I see it's done throughout, but why are these `open class`'s? \r\n\r\nNot seeing any implementation, feels quite misrepresentative to someone who is seeing this code for a review"
        ]
    },
    {
        "36556": [
            "Whole hearetdly believe all type discriminators should be named `type`. It makes it very self-evident what is driving the type resolution if the pattern is followed.\r\n\r\nLots of libraries default to this, like Moshi , and Kotlinx Serialization ([source](https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/json.md#class-discriminator-for-polymorphism), [docs](https://kotlinlang.org/api/kotlinx.serialization/kotlinx-serialization-json/kotlinx.serialization.json/-json-builder/class-discriminator.html)), and Jackson ([source](https://programmerbruce.blogspot.com/2011/05/deserialize-json-with-jackson-into.html))",
            "This is a pattern I've followed for what I believe is far-and-away the most complex polymorphic tree we have at Mobile currently, the ongoign implementation of [Server Driven UI for chat](https://github.aexp.com/pages/amichn/server-driven-ui/#tag/OpenAPI_Specification_other/paths/~1components/get)",
            "A few things to consider:\r\n- Clients likely shouldn't break on additional properties for most all API's\r\n- Jackson supports `@JsonIgnore` scoped to a property if absolutely needed\r\n\r\nAPI contract changes are good, from my perspective. They enable and inform clients, likely simplifying testing, and reducing the modalities of failure possible on their side"
        ]
    },
    {
        "36533": [
            "Can we make it polymorphic? This sounds like the time of data semantics we likely want to enforce via structure"
        ]
    },
    {
        "36532": [
            "This feels bad, can we null? This seems more subtle, and hard to track than null values, which are already suboptimal",
            "Can we keep this null instead of going to `\"\"`? Seems like we're hiding this again, similar to above \r\n\r\n```kotlin\r\nfun String?.maskEmail() = this?.let {\r\n    var startingIndex = 1\r\n    var endingIndex = this.indexOf('@') - 1\r\n    // If the email is a@gmail.com or ab@gmail.com, apply the logic below\r\n    if (endingIndex <= startingIndex) {\r\n        startingIndex = 0\r\n        endingIndex = this.indexOf('@')\r\n    }\r\n    this.replaceRange(startingIndex, endingIndex, \"*\".repeat(endingIndex - startingIndex))\r\n}\r\n```"
        ]
    },
    {
        "36344": [
            "We have to maintain this for making sure we don't add `chatIntents` to the response when fetching for older app versions hitting `/search/v1/feature`.\r\n\r\n[This is fundamentally because of the reuse happening right here](https://github.aexp.com/amex-eng/m1-msl/blob/546b451f334c86e3340d0bcb540cec4665b6ba67/backend-service-clients/search/contextual-search/src/main/kotlin/com/americanexpress/mobileone/bsc/contextual/search/ContextualSearchClient.kt#L73).",
            "Before this was:\r\n```kotlin\r\n        val searchType =\r\n            listOf(SearchType.FEATURES) + if (chatEligible) listOf(SearchType.CHAT_INTENTS) else emptyList()\r\n```\r\nThere's no change functionally, just cleanup, as I was reading I stumbled over this as it's adding two immutable lists in a very unusual way, so I made it more declarative but functionally identical.",
            "Sure, lines will still be changed, but can do. Fundamentally this parameter on line 262 has to be added, as we can no longer meaningfully tell chat eligibility solely from `CHAT_INTENTS` presence, as the older routes being hit should still respect their original rules of `chat eligiblity -> hit nlp for intents`",
            "There's no way for [this call](https://github.aexp.com/amex-eng/m1-msl/blob/61aa3d52e04a8b8c9821aa60d8688756d8fd4cc2/features/search/src/main/java/com/americanexpress/mobileone/search/v1/controller/SearchController.kt#L54) to indicate to the processor it needs to remove the chat intents responses in chat ineligible scenarios",
            "I mean i suppose it\u2019s potentially covered, but there\u2019s so much complexity here it\u2019s really challenging to keep track of, hence choosing the be explicit and declarative where possible (and inexpensive)",
            "Ooo nice catch",
            "Nice again, will do",
            "We have a huge amount of duplication in this file (20+ instances). This was just setting groundwork for cleaning up after.\r\n\r\nI feel like normally I\u2019d agree, but if we have 1 method being used in 20 places, it\u2019ll be really easy to grasp the expected general behavior for flows. Right now it requires lots of manual reading of duplication to understand.",
            "No issue, will include update",
            "No, meant to remove, have just done so",
            "Removed!",
            "Also to be clear, this code existed prior to my changes, I didn't add this actual logic, just made it less mutable",
            "Removed this, let me know if you want any other changes",
            "Personally I like it given it's not some \"execution to resolve\" but referencing an effectively (in the scope of the function execution) immutable ramp up flag"
        ]
    },
    {
        "36301": [
            "Personal Pref: This logic is hard for me to get on first read, not only with the null biconditional, but the config flag, and some opaque eligibility check\r\n\r\nHow would we feel about a bit of a change of approach? Kind of out of scope but wrote the code so wanted to drop here for you if you choose to use it.\r\n\r\n```suggestion\r\n    override fun createPaymentDueInfoV2(\r\n        card: CardDataBean,\r\n        statement: StatementSummaryDataBeanV2\r\n    ): DataElement? = pdiConfig?.let {\r\n        statement.paymentDueDate?.let { _ ->\r\n            if (isEligibleForDyp(card, statement)) createDypPaymentDueInfoV2(it, card, statement)\r\n            else createBauPaymentDueInfoV2(card, statement)\r\n        }\r\n    } ?: createBauPaymentDueInfoV2(card, statement)\r\n\r\n    private fun isEligibleForDyp(\r\n        card: CardDataBean,\r\n        statement: StatementSummaryDataBeanV2\r\n    ) = card.isBasic &&\r\n        (card.isConsumerCard || card.isCompanyCard) &&\r\n        card.isChargeCard &&\r\n        statement.isPayAndPlanOptionDisclosureIndicatorOn == true &&\r\n        serverFeatures.isConfigEnabled(DEFER_YOUR_PAYMENT_VITAL_MESSAGE)\r\n\r\n```\r\n"
        ]
    },
    {
        "36070": [
            "Fake so doesn't matter too much but don't want to do unnecessary string concat\r\n\r\n```suggestion\r\n        disclaimerText = \"\"\"\r\n        These payment amounts are not reflective of real time balances.\r\n        You can only pay up to 100000.0 online. Please enter an amount that does not exceed 100000.0 or pay via Amex PayID or BPAY.\r\n        \"\"\".trim(),\r\n```"
        ]
    },
    {
        "35974": [
            "I'd even say, as this date and it's numbers aren't meaningful (ie. not matching against fixed JSON), we shouldn't include them, but instead create an explicit instance in this modules scope which we use to assert self-asserting date values.\r\n\r\nSee the below for reference:\r\n* [Definition of shared value](https://github.aexp.com/amex-eng/m1-msl/blob/c5f27f5455d12a9a54c4fd4399909b3e53c079f8/backend-service-clients/messaging-v2-service-client/chat-service-client/src/test/java/com/americanexpress/mobileone/bsc/chat/test/support/models/conversation/api/FakeApiCommonValues.kt#L44)\r\n* [Inclusion in fake instance for testing model](https://github.aexp.com/amex-eng/m1-msl/blob/a05daa488387cf9e239fa589c4dc6a787b703652/backend-service-clients/messaging-v2-service-client/chat-service-client/src/test/java/com/americanexpress/mobileone/bsc/chat/test/support/models/conversation/api/messages/composite/FakeApiCompositeMessage.kt#L84-L88)\r\n* [Actual test usage of above model](https://github.aexp.com/amex-eng/m1-msl/blob/5d121de6870cc27463a695ad09751bc58b8cb4a0/backend-service-clients/messaging-v2-service-client/chat-service-client/src/test/java/com/americanexpress/mobileone/bsc/chat/conversation/models/client/message/CompositeAttachmentMessageMapperTest.kt#L11-L17)",
            "My first question when seeing this, as someone who knows nothing about this module is:\r\n\r\n> Why did they choose these values, and are they representing some significant boundary/threshold? \r\n\r\n\r\nIt's not often we use inline primitives in MSL code, so they stand out, which wen should leverage to imbue meaning",
            "Nit: Just getting rid of `null` as it pulls my focus when reading through file personally\r\n```suggestion\r\n            assertThat(paymentDueResponseV2).isNull()```",
            "Externalize the `now` to a shared instance which is used to show the identity property is the best way imo. Defining fixed dates that look meaningful will create illusions about what can/can't be changed (plus can share a single date all over easily which is nice)"
        ]
    },
    {
        "35964": [
            "Would personally really really avoid this, seems like a scary pattern to remove what is the discriminator (though I would have definitely named the status field type personally, as that's what it's driving realistically)\r\n\r\nSpecifically, it makes it impossible for clients to mirror MSL's inheritance, thus forcing them into duplication, or otherwise \"funky-stuff\" via adapter default types for no field present (and I'm sure many more headaches I'm nowhere near creative enough to think up).\r\n\r\nSpecifically, what do we gain from this removal? Seems rough, and are we doing this in the client contract? If so, how? Because for modeling polymorphism I'm absolutely certain OpenAPI requires a discriminator, and we enforce it in our custom processor"
        ]
    },
    {
        "35942": [
            "Prior this wasn't being mapped, so there was no issue. As this includes the mapping to client models we'll have to add this flow's tests after the ramp-up flag is added, to avoid too large of changesets",
            "This will propagate and result in needing to update E2E tests as they leverage the referenced models. \r\n\r\nI did have the tests included, but in pursuit of smaller change sets I removed them prior to raising.\r\n\r\nGiven there\u2019s no way for these to be  included in the feature response, I think it\u2019s fairly low risk, and am already stated with the tests for the subsequent update.",
            "This should be resolved now, a bit sloppy w/ the need for `copy`'s all over but will clean up once ramp-up flag is added and we can ensure confidently these changes won't have any impact"
        ]
    },
    {
        "35929": [
            "Shouldn't fakes reside in `testFixtures`? That way they can be used by other packages if needed (visibility rules obviously apply still) \r\n\r\n> [Link to fakes reference](https://docs.gradle.org/current/userguide/java_testing.html?_ga=2.160018041.53274471.1727813330-804898819.1712325128&_gl=1*q8ska0*_gcl_au*MzkxMTA3MDg2LjE3Mjc4MTMzMzA.*_ga*ODA0ODk4ODE5LjE3MTIzMjUxMjg.*_ga_7W7NC6YNPT*MTcyNzgxMzMzMC4xMS4wLjE3Mjc4MTMzMzAuNjAuMC4w#sec:java_test_fixtures)",
            "In my opinion this should be located at\r\n`features/points-transfer/src/testFixtures/com/americanexpress/mobileone/feature/pointstransfer/[*TypeName*]Fake.kt`"
        ]
    },
    {
        "35889": [
            "I'm generating the UUID on demand in the fake, didn't see any reason to hardcode and I like to randomize/decouple from the concrete instances where possible"
        ]
    },
    {
        "35379": [
            "I'm not sure I'm a fan of the 'eligible' nomenclature, as we're not so much concerned with that in reality, just whether we have a surveyId which is created, and thus submittable.\r\n\r\nWe aren't so much saying a user \"isn't eligible\" as we're saying \"backend didn't create you a survey this time\". Not a huge deal, but wanted to give my 2c",
            "I echo the fake here, I think it makes the subsequent tests much clearer, and good practice on a thin interface",
            "May be out of scope for this change, but personally I'd definitely default these values if this is the current state, the nulls are crazy lol\r\n\r\n[Field class](https://github.aexp.com/amex-eng/m1-msl/blob/71daf61cbd8cec743dd416b2c85b8f60a21f7331/features/messaging/src/main/java/com/americanexpress/mobileone/messaging/v2/config/SurveyTemplates.kt#L23-L35) for ref",
            "```suggestion\r\ninternal val fakeSurveyEligibilityClientResponseWithInvalidTemplate = fakeSurveyEligibilityClientResponse.copy(templateName = INVALID_TEMPLATE_NAME)\r\n```",
            "Super neat functionality in Kotlin, see [reference to docs here](https://kotlinlang.org/docs/data-classes.html#copying)",
            "Yeah we can for sure, was already merged in more of a comment than anything else"
        ]
    },
    {
        "35358": [
            "Pretty Nit: This will give us a more insightful error in the event we get one, as it will have a call stack whereas NPE will not.\r\n\r\n```suggestion\r\n           with(checkNotNull(initLabels.get().taxIdScreen)) {\r\n```"
        ]
    },
    {
        "35252": [
            "What's this explicit null for?",
            "Reminder on the fast follower for resolution of [this](https://github.aexp.com/amex-eng/m1-msl/pull/35252#discussion_r2947139) very opaque explicit null -> hidden default case"
        ]
    },
    {
        "35202": [
            "Does this need to be a `when` if it's just biconditional?",
            "```suggestion\r\n        if (readPaymentOptionsClientResponse is ReadPaymentOptionsClientResponse.IneligiblePaymentDetails) {\r\n                Outcome.success(\r\n                    PaymentsInquiryDetailsV3.IneligibleCardInquiryV3(\r\n                        title = paymentInquiryLabels.customErrorLabels.ineligible.title,\r\n                        message = paymentInquiryLabels.customErrorLabels.ineligible.message,\r\n                        buttonText = paymentInquiryLabels.customErrorLabels.ineligible.buttonText\r\n                    )\r\n                )\r\n        } else {\r\n            Outcome.error(PaymentsError(statusCode = PaymentsCode.BACKEND_DATA_INVALID))\r\n        }\r\n```"
        ]
    },
    {
        "35163": [
            "Could clean up this `when` statement with only 2 branches, and make it a `if () {...} else {...}`, as it's unclear that it's only 2 choices by the `when`.\r\n\r\n",
            "Could make this `if else` as well"
        ]
    },
    {
        "35078": [
            "Do we actually want to import this logger? Seems like a misuse even if it is on purpose",
            "Importance to be clear is this will log with the loggers package coordinates, which will make any errors we try to log look like they're from `OverviewPersonalizationProcessor` , rather than `CustomerMessagesProcessor`",
            "Approved just to remove my explicit \"Changes Needed\""
        ]
    },
    {
        "34971": [
            "It definitely could be, though this was the way it was originally. I'm not certain as I was unable to find out how it's even being presented currently, and I'm unfamiliar with JSP in general"
        ]
    },
    {
        "34915": [
            "I'm a genius...",
            "Sorry had 1x1 which stole me away just before pushing, pushed now",
            "Rolled back the update!"
        ]
    },
    {
        "34891": [
            "This being nullable is a code smell in my opinion. This should be an `Outcome`, like the [Reference Implementation](https://github.aexp.com/amex-eng/m1-msl/blob/281cfbebff9b10ba1a7dab1fb435b52ee8c2a1b5/features/reference-implementation/src/main/java/com/americanexpress/mobileone/referenceimplementation/ReferenceImplementationNormalizer.kt#L19-L22)",
            "+++1",
            "Even if you think you can, you should write an explicit mapper from Client enum to feature enum in my opinion.\r\n\r\n[Here's an example of doing so](https://github.aexp.com/amex-eng/m1-msl/blob/f3764635f30409f469683bb88c37cc797fdb9903/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/mappers/composite/CompositeMessageMapper.kt#L331-L337). This also provides much tighter bounds on things like test logic, as it's known to be an exhaustive mapping, meaning edge cases validation is unnecessary without weakening our confidence in the code."
        ]
    },
    {
        "34847": [
            "Awesome!"
        ]
    },
    {
        "34842": [
            "Super super nit: Just for readability, prefer to keep functional invocations and subsequent executable block on the same line if it's a 1 liner.\r\n\r\n```suggestion\r\n                    countryList = validationCriteria.findNationalityCountryList()\r\n                            .mapNotNull { it.toScreenCountryChoice(initLabels.get().staticData.countryList) },\r\n```"
        ]
    },
    {
        "34834": [
            "What about something like this?\r\n\r\n```suggestion\r\nprivate fun ErrorScreen.createErrorScreenWithAccountKeySsoLink(accountKey: String) = copy(\r\n    buttons = buttons.map { it.copy(ssoLink = it.ssoLink?.uniTemplate?.globalUrl(accountKey)) }\r\n)\r\n\r\nprivate fun UniTemplate<String>.globalUrl(accountKey: String) = GlobalUrl(format(accountKey))\r\n\r\nprivate val GlobalUrl.uniTemplate: UniTemplate<String> get() = UniTemplate(url.replace(ACCOUNT_KEY, \"%s\"))\r\n\r\n```"
        ]
    },
    {
        "34760": [
            "Kind of don't love the returns personally, in general opposed to multiple control flows through a function, and especially these eager returning ones can be deceptive imo, quick example of how I may write this to avoid it\r\n\r\n```suggestion\r\n@Suppress(\"CyclomaticComplexMethod\")\r\ninternal fun Capability.isCardEligibleH(\r\n    appClientMetaData: AppClientMetaData,\r\n    card: CardDataBean\r\n): Boolean = when {\r\n    !isEnabled -> false\r\n    filters.isEmpty() -> true // If no filter is configured, consider eligible\r\n    else -> {\r\n        fun checkEligibility(cardTypes: List<CardProperty>): Boolean =\r\n            cardTypes.any { it.isConditionOf(card, appClientMetaData) }\r\n        filters.eligibleCardTypes.isEmpty() ||\r\n            checkEligibility(filters.eligibleCardTypes) ||\r\n            isEligibleConditionSatisfied(card, filters.eligibleConditions) &&\r\n            !(filters.excludedCardTypes.isNotEmpty() && checkEligibility(filters.excludedCardTypes))\r\n    }\r\n}\r\n```",
            "Why explicitly set these if we have defaults?"
        ]
    },
    {
        "34753": [
            "Oh yeah certainly"
        ]
    },
    {
        "34695": [
            "Ahh I don't love this, but I see we're getting these from a java dist. \r\n\r\nIdeally was hoping to enable `.copy()` for this, as it lets you retain the upside of immutable attributes, while also minimizing duplicated initializers. We could do it with the `expected` responeses though"
        ]
    },
    {
        "34673": [
            "oop",
            "I think you can remove this header? Or wildcard its matching to avoid this"
        ]
    },
    {
        "34366": [
            "What is the use for this? \r\n\r\nPersonally I find this almost \"deceptive\", because the strings look otherwise the same unless you check `isBlank`, which feels like we're passively dropping info",
            "[See how I solved this issue here](https://github.aexp.com/amex-eng/m1-msl/blob/ec632576b645969d5470db5edee4cb8184b35cfe/common/msl-common/src/main/java/com/americanexpress/mobileone/util/NotBlankString.kt#L3-L17)",
            "Client meaning mobile apps, right? Seems like a pretty bad pattern, I'm not going to try and dictate anything, though I would say if it was me, I'd most certainly try to get them to evaluate other approach if at all possible. Blank strings are going to cause headaches, especially explicitly blank ones, as we are effectively breaking the type system by having a null pseudotype.\r\n\r\n[This quote is from this blog post I really like on this topic](https://www.samjarman.co.nz/blog/empty-string):\r\n> By inventing our own indicator for optional strings - the empty string - we get no such help, and bugs find their way in very quickly, even with guards such as documentation.",
            "A good litmus check is also the fact that someone not 'in the know' (like me), will look. at this code and be entirely mystified.",
            "This seems like we should have some `Transaction.DetailsItem.Counterparty.Zelle.Value` class with the token required, and another `Transaction.DetailsItem.Counterparty.Default.Value` with the token not present at all.\r\n\r\nWe should likely have a parent abstraction, `Transaction.DetailsItem.Counterparty.Base.Value` to capture truly shared attributes.\r\n\r\nJust some thoughts, I'll approve, but think there's definitely some room here to make it more dependable, transparent, and maintainable down the road (the current approach is also really hard to guarantee test coverage of)"
        ]
    },
    {
        "34276": [
            "This covers both mappers and client models simply as it was super challenging to split the two and still have functional fakes + samples. Became a pretty big headache, decided to couple them as I think the changes are fairly clean. Let me know if any concerns\r\n"
        ]
    },
    {
        "33913": [
            "Would it make sense to do something like this? Feels like they are semantically linked, though I just poked around real quick, not a ton of 'context' \ud83e\udd23  (sorry) on this backend client.\r\n\r\n```suggestion\r\nsealed interface Context {\r\n    val correlationId: CorrelationId\r\n    val appToken: JsonWebToken\r\n\r\n    companion object {\r\n        operator fun invoke(\r\n            correlationId: CorrelationId,\r\n            appToken: JsonWebToken\r\n        ): Context = ContextImpl(correlationId, appToken)\r\n    }\r\n\r\n    private data class ContextImpl(\r\n        override val correlationId: CorrelationId,\r\n        override val appToken: JsonWebToken\r\n    ) : Context\r\n}\r\n\r\ndata class ProductEligibleContext(\r\n    override val appToken: JsonWebToken,\r\n    override val correlationId: CorrelationId,\r\n    val a2aJwt: JsonWebToken\r\n) : Context\r\n\r\n```",
            "Could also do the headers creation as an interface method, if it should be defined for all contexts",
            "Yeah of course, good luck haha"
        ]
    },
    {
        "33907": [
            "Yeah good point!",
            "This is actually handled via [this set of variables](https://github.aexp.com/amex-eng/m1-msl/blob/7d59a5aa4a5e7187a12aa5708d4aba2277536003/backend-service-clients/messaging-v2-service-client/chat-service-client/src/test/java/com/americanexpress/mobileone/bsc/chat/test/support/models/conversation/api/FakeApiCommonValues.kt#L43-L44)\r\n\r\nI handled it in a 2 pronged approach:\r\n1. Deserialization needs assertions, as we have to validate we're ingesting the time accurately per the backends response\r\n  * This should be a static 'absolute' timestamp, as it has to be included in the JSON file for deserialization validation\r\n2. Conversation to labels for status badge needs assertions, but this is only minute-fidelity. This means we're safe as long as any specific unit test doesn't take > 60 seconds (which is a reasonable thing to presume)\r\n"
        ]
    },
    {
        "33805": [
            "Guessing that null is given if never touched, empty if fetched prior but no add, or can be empty when added -> deleted"
        ]
    },
    {
        "33595": [
            "oops, totally forgot, will do now!"
        ]
    },
    {
        "33593": [
            "This feels pretty convoluted, there's definitely a more sleek solution using something like `require` or `requireNotNull`",
            "Ahh I see , okay, this data structure seems like it's quite challenging to work with because of all the nullability"
        ]
    },
    {
        "33528": [
            "Nice lazy instantation! Really useful for moshi, as you protect from there being an adapter 'access before registration' race!"
        ]
    },
    {
        "33434": [
            "Can we seal this class? Good to take advantage of Kotlin's type system during this conversation wherever possible\r\n\r\n```suggestion\r\nsealed interface Title {\r\n```",
            "It could, though as a general rule I think the implementations should be internal if the interface is going to be, else there's no advantage. Basically imo it's a liskov violation to make the root internal while keeping concrete instances public, though that's definitely an opinion not a fact",
            "Can we move these out of this companion object? \r\n\r\nIf not, we should at least make the companion object `internal`, we shouldn't be exposing these as part of the API surface.",
            "They are enum's too, to make it even better"
        ]
    },
    {
        "33408": [
            "Maybe nit: We don't even need an explicit failed response, do we? \r\n\r\nFrom the calling code, I can the `failed` response just results in us calling an error manually down the chain, why not have Moshi/OkHttp handle that for us and throw it upon response ingestion? This gives a sense of this failed response being useful, but it isn't, and it's a bit deceiving as we're using a singleton object as the sibling to the constructed instance in the success flow."
        ]
    },
    {
        "33314": [
            "Nit: Big fan of unique ID's having value classes associated with them, they're not just a string, but a very important one :) "
        ]
    },
    {
        "33292": [
            "Nice catch, definitely not"
        ]
    },
    {
        "33255": [
            "I personally really dislike the notion of a log being capable of causing a test failure"
        ]
    },
    {
        "32968": [
            "These aren't being serialized by Jackson, but rather Moshi. This is because of some super super weird restrictions on the Chat feature. We tried hard, but right now it just doesn't make sense to take on the headache of feature models.\r\n\r\nJackson I think we require them, but honestly I'm not nearly as handy with Jackson as I am Moshi."
        ]
    },
    {
        "32885": [
            "Yes, if it's present it must include at least 1 element. We do not accept a zero length array",
            "Because we have a need for a validation on initialization, as this is bound by regex in the contract"
        ]
    },
    {
        "32873": [
            "If this list can't be empty we should specify so, via `NonEmptyList`",
            "Same here for `NonEmptyList`",
            "And here",
            "If this can be empty, we should add fakes to support that flow as well",
            "What's going on here that we need a list for what is a guaranteed single item?"
        ]
    },
    {
        "32612": [
            "Yeah exactly, this is just providing the mechanism to facilitate that while keeping changes minimal."
        ]
    },
    {
        "32591": [
            "Opened #32612 to try and minimize change set"
        ]
    },
    {
        "32131": [
            "Previously we needed to do some fairly annoying handling of test data to enable deserialization testing without adding the data to the mapped flow. We are now able to remove this",
            "Same as above is true here",
            "Yeah here it's safe, let me update"
        ]
    },
    {
        "31935": [
            "Yeah let me update test to be a pure check instead of the shallow keys"
        ]
    },
    {
        "31866": [
            "Could even simplify this one bit more ;) Hugely agree though, mutablility is as close to \"original sin\" as there is, in my opinion. \r\n\r\n\r\n```kotlin\r\nval validationValue = getCreditLimits(creditLimits, cardDataBean) ?: when {\r\n    cardDataBean.isChargeCard, cardDataBean.isCorporate -> MAX_LIMIT\r\n    else -> TEXTBOX_DEFAULT.toDouble()\r\n}\r\n```",
            "We could do something like this, to simplify this and remove the intermediaries.\r\n\r\n```kotlin\r\n    private fun constructPicker(\r\n        selectedValue: String,\r\n        defaultValue: String,\r\n        pickerLabel: String,\r\n        possibleInputs: List<LabelValue>\r\n    ): InputPicker = InputPicker(\r\n        currentSelection = with(possibleInputs) {\r\n            firstOrNull { it.value == selectedValue } ?: first { it.value == defaultValue }\r\n        }.label,\r\n            pickerLabel = pickerLabel,\r\n            possibleInputs = possibleInputs\r\n        )\r\n\r\n```"
        ]
    },
    {
        "31811": [
            "Oops \ud83d\ude48 resolved",
            "no way it was in my regex replace ahhh"
        ]
    },
    {
        "31720": [
            "I'm personally pretty huge on reusability, and luckily `ActivatableCardClientResponse.ActivatableCard` is a `data` class, so we can leverage [Kotlin's `copy` operator](https://kotlinlang.org/docs/data-classes.html#copying), and replace this block with the below. Not only is it more concise, it's much more expressive, as you clearly define the \"changed\" data in the `copy` call, and it's less fragile as we have less code to do upkeep on due to these \"root instances\" doing a lot of the heavy lifting across the code.\r\n\r\nNote, we cut almost 30 lines of repetitive, non-critical, and ultimately superfluous code.\r\n\r\n```suggestion\r\nconst val FAKE_DIGITAL_ASSET_ID = \"NUS000000269\"\r\nconst val FAKE_ACCOUNT_TOKEN_RAW = \"accountToken1\"\r\nval accountToken = AccountToken(FAKE_ACCOUNT_TOKEN_RAW)\r\nconst val FAKE_CARD_ENDING = \"12345\"\r\nconst val FAKE_PRODUCT_DESCRIPTION = \"American Express Gold Card\"\r\nprivate val defaultActivatableCard = ActivatableCardsClientResponse.ActivatableCard(\r\n    accountToken = accountToken,\r\n    digitalAssetId = FAKE_DIGITAL_ASSET_ID,\r\n    cardEnding = FAKE_CARD_ENDING,\r\n    cardType = CardType.CONSUMER,\r\n    productDescription = FAKE_PRODUCT_DESCRIPTION,\r\n    isAccountLock = false,\r\n    issuanceType = IssuanceType.NEW_ACCOUNT,\r\n)\r\n\r\nval singleActivatableCardsClientResponse = ActivatableCardsClientResponse(listOf(defaultActivatableCard))\r\n\r\nval singleActivatableCardsNonConsumerClientResponse =\r\n    ActivatableCardsClientResponse(listOf(defaultActivatableCard.copy(cardType = CardType.CORPORATE)))\r\n\r\nval singleReplacementActivatableCardsClientResponse = ActivatableCardsClientResponse(\r\n    activatableCards = listOf(defaultActivatableCard.copy(issuanceType = IssuanceType.REPLACEMENT))\r\n)\r\n\r\nval replacementAndNewLinkedActivatableCardsClientResponse = ActivatableCardsClientResponse(\r\n    activatableCards = listOf(\r\n        defaultActivatableCard.copy(issuanceType = IssuanceType.REPLACEMENT),\r\n        defaultActivatableCard.copy(\r\n            issuanceType = IssuanceType.NEW_ACCOUNT,\r\n            accountToken = AccountToken(\"accountToken2\"),\r\n            productDescription = \"American Express Preferred rewards Card\"\r\n        )\r\n    )\r\n)\r\n\r\n```",
            "We also reference these string primitives extensively, when I used the variable extraction refactor command in IntelliJ, every string had 10+ usages. We could simplify all of those to a single string literal realistically.",
            "This comment seems \"out of place\" for MSL (and also fragile in its accuracy). ",
            "Kinda nit (but also I definitely struggled here):\r\nThis boolean was pretty confusing to read, I might suggest something like the below, to separate out specific conditions scoped to one object. \r\n\r\n```suggestion\r\n    private fun List<ActivatableCardsClientResponse.ActivatableCard>.isEligible(): Boolean =\r\n        appClientMetaDataProvider.get().isVeryHighRisk()?.not() ?: false &&\r\n            serverFeatures.isConfigEnabled(NEW_LINKED_CARD_ENROLLMENT) &&\r\n            size == ACTIVATABLE_CARDS_SIZE &&\r\n            any { it.isEligibleForActivation() }\r\n\r\n    private fun ActivatableCardsClientResponse.ActivatableCard.isEligibleForActivation(): Boolean =\r\n        issuanceType == IssuanceType.NEW_ACCOUNT && cardType == CardType.CONSUMER\r\n\r\n```",
            "Can we use polymorphism to avoid this nullability in the `CardSelectorScreenResponse`. \r\n\r\nHappy to provide an example of how I might approach if you'd like!",
            "Would recommend exploring the `copy` approach for these as well"
        ]
    },
    {
        "31695": [
            "It's not simple client composite mappings though, we either have to map all of them, or none. \r\n\r\nMy thinking was \"Right now the only delta between the two models is composite, but potentially that may change, and this will be a subtle 'point of failure' if that does, which I could very easily see being missed\"",
            "I would ideally have us propagate the composites to the feature layer via the `ClientReselientCompositeMessage` abstraction, but we have to eagerly transform into `Map<*, *>` as of today. I figured I'd leave that out, but it would greatly simplify, clarify, and make more extensible this functionality were we able to do so.",
            "Honestly this part I wasn't sure about to be totally honest, we did receive something like that, but wanted to get these changes in prior",
            "Yeah this is definitely the better option, let me do so now!",
            "Good catch, let me add some serialization tests, this is a miss for certain",
            "We would just be re-apply the behavior we just applied, right? I think the delegation to the client is really the only way to do so, given we're serializing to a `Map<*, *>` prior to sending it back to clients",
            "Yeah I've updated a static placeholder for the time being. I can also set up logging alerts if we want for this flow being hit. It shouldn't be given the backend currently isn't sending this data ",
            "It's going to, for the time being though we wanted to keep it simple, I have a large change set I've split into 3 pull requests immediately following this. This is also off the critical path, behind ramp up, and we shouldn't even receive composites in the first place"
        ]
    },
    {
        "31534": [
            "Added!"
        ]
    },
    {
        "31182": [
            "This is marked as `ignore = true` to make it not applicable for deserialization. The reason I added this as an explicit enum was to support passing this back to feature level in the future to support dynamic handling as the feature sees fit. Fundamentally, we would handle this at the feature level in Mobile typically, I'm just trying to slowly but surely make chat less of a \"special case\" in m1 code.",
            "Effectively what this does is attempt to deserialize the composite, but if we fail, we try to deserialize this `FallbackTextMessage` type, which is really just the minimal set of attributes required to create a valid text message (sans the `content.desc`). This is effectively things like `messageid`, `userid`, `conversationid`, `create_time` etc.\r\n\r\nIn the case where that also fails, we treat it as a genuine error, as it's an unrecoverable error state.",
            "@fsudeepk the uncovered aspects are the client mappers which can't be covered in this change set (but are the impetus behind it, and already present in the stacked PR's), the mapper function override for `ApiFallbackTextMessage` ([link to Sonar](https://sonar.aexp.com/component_measures?id=amex-eng.m1-msl&metric=new_uncovered_lines&pullRequest=31182&view=list&selected=amex-eng.m1-msl%3Abackend-service-clients%2Fmessaging-v2-service-client%2Fchat-service-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Famericanexpress%2Fmobileone%2Fbsc%2Fchat%2Fconversation%2Fmodels%2Fapi%2Fmessage%2FApiFallbackTextMessage.kt)) and `ClientFallbackTextMessage` ([link to Sonar](https://sonar.aexp.com/component_measures?id=amex-eng.m1-msl&metric=new_coverage&pullRequest=31182&view=list&selected=amex-eng.m1-msl%3Abackend-service-clients%2Fmessaging-v2-service-client%2Fchat-service-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Famericanexpress%2Fmobileone%2Fbsc%2Fchat%2Fconversation%2Fmodels%2Fclient%2Fmessage%2FClientFallbackTextMessage.kt)).\r\n\r\nThere's no way to get coverage here without a huge increase in this scope, which I've already split across the currently open stacked changes"
        ]
    },
    {
        "31033": [
            "Can use `TODO(\"some string to throw\")` to seamlessly handle these scenarios, in case you didn't know!",
            "Big fan of the below approach to reduce upkeep required on tests:\r\n```suggestion\r\ninternal val fakePushUpdatePreferenceRequestForCardAlertWithInputNoAccountTokens =\r\n    fakePushUpdatePreferenceRequestForCardAlertWithInput.copy(accountTokens = emptyList())\r\n```",
            "Same here\r\n```suggestion\r\ninternal val fakePushUpdatePreferenceRequestForCardAlertWithInputMultipleAccountTokens = fakePushUpdatePreferenceRequestForCardAlertWithInput.copy(\r\n    accountTokens = listOf(accountTokenFake, accountTokenFake2)\r\n)\r\n```",
            "Similar to the `copy` bindings, I like the approach of driving JSON contents via test instances. We don't care about the data itself presumably, just the `input -> expected output`, so still totally valid, and makes it less likely we have a \"oh shoot I need to update that string\" moment after we change some test data, or vice versa.\r\n\r\n```suggestion\r\n@Language(\"JSON\")\r\ninternal val clientPushEnrollRequestJson = \"\"\"\r\n{\r\n  \"accountToken\": \"${accountTokenFake.token}\",\r\n  \"encryptionKey\": \"${encryptionKeyFake.value}\",\r\n  \"pushToken\": \"${pushTokenFake.value}\"\r\n}\r\n\"\"\".trimIndent()\r\n```",
            "Also, just a note, but all these should most certainly be underpinned by `value` classes, not `data` classes. This is usually the case when you have a single-arg no-function data class.\r\n\r\nI've implemented this all over, especially in messaging, and found it enormously useful. Here's a [quick example](https://github.aexp.com/amex-eng/m1-msl/blob/c0e1a161a4f4bc62a2d315407e0d8efc38f2d647/features/messaging/src/main/java/com/americanexpress/mobileone/messaging/v3/model/conversation/values/UserId.kt#L6-L13) of a Jackson-serializable instance. \r\n\r\nI'm going to raise a change to add support for `jackson-kotlin-module` to main now, but this would depend on it technically",
            "Does this need to be an outcome? I'm not overly familiar with this code, but this looks like we're doing a purely mechanical set of derivations on this data to get some new request payload, why sequential?"
        ]
    },
    {
        "31026": [
            "Okay, I can move them out, I was a bit wary of creating a single mapper file, but let me see if I can't structure it so that components are in separate files and general composite messages are contained in a single file",
            "I can add, but we're enforcing non-empty on the `(ApiScreen).components` anyways, so it shouldn't be an issue",
            "I've updated this to avoid needing to do either, as we maintain the requirement from the original instantiation. As there's nowhere new to violate this we should be perfectly safe to assume any & all failures due to emptiness will happen eagerly at deserialization time.",
            "Yeah, removed this now"
        ]
    },
    {
        "30863": [
            "No, let me remove this"
        ]
    },
    {
        "30848": [
            "What do you mean? Sorry, unclear what you're asking we add for `TITLED`",
            "I can include",
            "Sure, let me add after grabbing food",
            "I've intentionally ignored as currently it's undefined, and we should never gte v2, so failing is what I expected we'd want. Happy to discuss though",
            "It's not actionable though, right? Like we're not driving the consumption of disparate models based on it? I'm not sure what it does honestly, seems odd to have, do we want to do anything with it? ",
            "This is fixed now"
        ]
    },
    {
        "30839": [
            "Yes, just fixed"
        ]
    },
    {
        "30802": [
            "Yeah, realized this now as well , removing",
            "Yeah, it's a whole headache, but agree w/ reflection being scary, it's been removed"
        ]
    },
    {
        "30738": [
            "There was an issue w/ the polymorphic JSON adapter"
        ]
    },
    {
        "30723": [
            "Nope, good ol' mistake \ud83d\ude05 Fixed now",
            "Added one, I don't think there's an analog for `assertDoesNotThrow` in assertK, but if you have a non-Jupiter way to handle I'm open to it",
            "We can do so via init validations, but I was attempting to create a programmatic way of enabling you to pass a raw string literal to a function and get back a value wrapped, validated instance of some child of `NonEmptyStringValue` (ie. `OfferId`).\r\n\r\nBasically, with this code, we can do the below:\r\n```kotlin\r\n        val value = \"fake-value\"\r\n        val fakeValue = nonEmptyString<FakeValue>(value)\r\n```\r\n\r\nWithout this code we'd have to do:\r\n```kotlin\r\n        val value = \"fake-value\"\r\n        val fakeValue = FakeValue(NonEmptyString(value))\r\n```\r\n\r\nI found myself wanting this when I was writing tests, as it felt potentially a bit ambiguous and disincentivizing to have to doubly wrap the string to get the value class with a non-blank string",
            "Looking at this now though I'm not sure it's justified",
            "This is a great point actually haha, let me resolve",
            "Added this in!",
            "This is used as a marker for \"yes we did complete all the above actions successfully\". It creates an explicit happy path. Not pretty, but best we can do without using `Jupiter`",
            "Removed",
            "Yeah I actually like this quite a lot, thanks!",
            "> Curious, when we would need to have a NonEmptyString or a value class for string, couldn\u2019t we just use kotlins `String` vs `String?`?\r\n\r\nA nullable string is seperate from a non-empty string though. Without this construct we can only say \"the string exists\" or \"the string does not exist\", we can't posit anything regarding its' \"emptiness\", which has been a persistent theme of lots of the ValGen discussions.\r\n\r\nWhereas we had the two statements above, with this construct we can additionally reason on the basis of \"the string is empty\" and \"the string is not empty\", which are fairly rich and useful assertions. \r\n\r\nThe guiding original motivation was:\r\n> Hmmm, I need to assert this for a ton of the fields, and I think doing so manually would be opaque, hard to test, and fragile. What if I created an interface for value classes to handle this, with some custom string implementation similar to our [`NonEmptyList`](https://github.aexp.com/amex-eng/m1-msl/blob/9649c82829303542066524a5106c36441f029996/msl-common/src/main/java/com/americanexpress/mobileone/NonEmptyList.kt#L1-L0) implementation. Then I could follow the same pattern of \"this string is not empty\" that we're using in our OpenAPI definition, without incurring the maintence overhead and inevitable \"misses\" that will occur from a more manual implementation."
        ]
    },
    {
        "30562": [
            "Super nit:\r\nNaming seems funky to me personally. I think I'd name this something like `normalizeTransfer`, just postfixing with the new discriminator we added in this change set. Reason being, we know we are in a \"Inquiry Normalizer\", so this seems superfluous personally.\r\n\r\n```suggestion\r\n    fun normalizeTransfer(\r\n```",
            "See above"
        ]
    },
    {
        "30554": [
            "Good point",
            "We don't actually have this guarantee technically, I'll see if we can add it, because it seems super reasonablle",
            "Yeah was thinking of that, let me move",
            "We do need to enforce this, yes, it's explicitly defined as such ",
            "Updated!",
            "See [this change ](https://github.com/FasterXML/jackson-module-kotlin/pull/768) where it was fixed, and [this](https://github.aexp.com/amex-eng/m1-msl/pull/26816#pullrequestreview-4745567) for reference where we merged this into our repo.",
            "Okay for sure, was going to wait but more than happy to do now",
            "Fixed",
            "Yeah meant to, apologies, adding now",
            "I'm trying to adhere to \"best practices\" for MSL, and we do have meaningful tests over the current feature layer models. This work needs to be done regardless, and the intention here was not coupling the BSC Client output to feature output, as we intentionally follow this pattern throughout MSL. \r\n\r\nI also want to keep the feature layer in a state where we could swap the serialization on at any point and it would \"just work\".",
            "Yeah, me and @fsudeepk discussed and aligned on same. I have moved in that direction now, and am just finishing cleaning up the old code to prepare moving these over"
        ]
    },
    {
        "30065": [
            "Yeah good point"
        ]
    },
    {
        "29849": [
            "Fixed"
        ]
    },
    {
        "29808": [
            "Love love love that you're explicitly calling `T.copy(...)` here, excellent example of keeping things \"up-to-date\" in a cost-free manner long term via Kotlin stdlib \u2764\ufe0f "
        ]
    },
    {
        "29800": [
            "Yeah I was actually looking at this right now, will be pushing shortly applying now"
        ]
    },
    {
        "29711": [
            "Going to create a new pull request, this one refuses to build for some reason"
        ]
    },
    {
        "29664": [
            "Yeah, let me do so, saw it's repetition and figured I'd clean up, but this is a good point",
            "My goal was to avoid making it public/internal, as I hope (given discussion with backend) that this is very temporary. I intentionally tried to make it hard to use/discover, to discourage it being used. Ultimately, we definitely shouldn't be doing this, and we're again seeing new anti-patterns that are otherwise not present in MSL required in some of these modules."
        ]
    },
    {
        "29640": [
            "```suggestion\r\n        destination = \"amexapp://replaceCard\",\r\n```",
            "I think for maintainability the below is a nice change\r\n\r\n```suggestion\r\nval fakeSemanticSearchClientResponseWithEmptyFeature = fakeSemanticSearchClientResponse.copy(features = listOf())\r\n\r\nval fakeSemanticSearchClientResponseWithEmptyFaqs = fakeSemanticSearchClientResponse.copy(faqs = listOf())\r\n```",
            "Nit: I personally don't love how different the `faqs` and `features` parameters appear, since they're ultimately a pretty similar operation. The thought I had was something like the below:\r\n\r\n```suggestion\r\ninternal fun SemanticSearchResponse.toSearchSemanticsResponse(chatIntentsResult: SearchSemanticsResponse.Results) = SearchSemanticsResponse(\r\n    searchId = searchId,\r\n    faqs = if (faqs.isEmpty()) NoResults() else SearchSemanticsResponse.Faqs(results = faqs.map { it.toFeaturesResult() }),\r\n    features = if (faqs.isEmpty()) NoResults() else SearchSemanticsResponse.Features(results = features.map { it.toSemanticFeaturesResult() }),\r\n    chatIntents = chatIntentsResult\r\n)\r\n\r\nprivate fun SemanticSearchResponse.Feature.toSemanticFeaturesResult() = Feature(\r\n    destination = destination,\r\n    featureName = name,\r\n    iconName = iconName\r\n)\r\n```",
            "Same `.copy()` comment applies here. Think it's good practice, especially w/ these multiplexing cases, they're going to be a pain down the road if we don't plan for it now",
            "The name clashes here scare/confuse me a bit, maybe instead could do something like below:\r\n\r\n```suggestion\r\ninternal fun NlpFeatureChatIntentClientResponse.toSemanticChatIntentsResponse() = mapToChatIntents(chatIntents).orEmpty().let {\r\n    if (it.isEmpty()) SearchSemanticsResponse.NoResults() else SearchSemanticsResponse.ChatIntents(it)\r\n}\r\n\r\n```"
        ]
    },
    {
        "29636": [
            "No longer applicable as this was resolved in #29640 "
        ]
    },
    {
        "29618": [
            "Good catch, definitely missed both nullability here",
            "Yeah good point",
            "Oops, definitely should, same for `user_id`, let me update",
            "Yes, based on the discussion we had this should be the case was my understanding, though I was definitely missing some background on it so I may be wrong here. If so, what should this be based off of? \r\n\r\nMy assumption was that this content wasn't going to be present for users whom aren't chat eligible, so if it is present, they must be, and thus we should map them.",
            "Done",
            "I'm reusing the prior one for the time being, was planning to take up adding a new one in a subsequent change, but can include here if you'd prefer? Was aiming to keep change set as small as reasonably possible",
            "Yeah definitely, let me update with those",
            "Updated this",
            "Updated this",
            "Yeah let me add w/ the changes I'm about to push, apologies",
            "These were superfluous, I can revert, but there's no need and they just add complexity for testing"
        ]
    },
    {
        "29612": [
            "Was just driving this based off contract \ud83d\ude05 will update",
            "Sure can do",
            "Yeah, was separating just so code was easier to delete down the road, but can reuse w/o any issue",
            "Client info is present in same way as others in same module, see [here](https://github.aexp.com/amex-eng/m1-msl/blob/0a609d631ac89a948b3a186311b3bcb6a732caba/backend-service-clients/search/contextual-search/src/main/kotlin/com/americanexpress/mobileone/bsc/contextual/search/ContextualSearchClient.kt#L17-L30). Any concerns w/ this approach?"
        ]
    },
    {
        "29383": [
            "Love this"
        ]
    },
    {
        "28795": [
            "I'm Dumb holy"
        ]
    },
    {
        "28239": [
            "Nit: hyperlinks are more usable and make people more likely to actually confirm with the source\r\n\r\n```suggestion\r\n                 [ReadCustomerDomainDataValidation.sor.v1](https://explorer.aexp.com/functions/ReadCustomerDomainDataValidation.sor.v1)\r\n                 [PON Validation Swagger](https://github.aexp.com/pages/amex-eng/c360-feature-dynamic-validator/171/merge/swagger.html#operation/getPonValidations)\r\n```",
            "Would definitely hide this link in a hyperlink personally.\r\n\r\n```suggestion\r\n[Dashboard](https://ngisplunk.aexp.com/en-US/app/mobile/kjsfkjhd?form.field1.earliest=-30d%40d&form.field1.latest=now&form.markets=com.americanexpress.android.acctsvcs.es%20es.co.americanexpress.amexservice&hideFilters=false) to monitor daily volume / TPS for all functions:\r\n\r\n```"
        ]
    },
    {
        "27904": [
            "Super nit: Is this a fake or a stub? I've heard fakes being \"pseudo implementations\" whereas stubs are more in line with these \"give the output you want as input\""
        ]
    },
    {
        "27820": [
            "Updated"
        ]
    },
    {
        "27669": [
            "Ideally there's a lot of room to improve this, we can bind document types to keys, and use type reification to both deserialize and enforce type consistency. \r\n\r\nI have lots of thoughts, Kotlin opens some very cool doors with its' type engine.\r\n I've written a very very comprehensive Couchbase SDK in Java, and I think it was quite excellent honestly, but Kotlin enables a dramatically better final product with a fraction of the effort.\r\n\r\n[Link to my full scope wrapper for the Couchbase Java SDK](https://github.aexp.com/amex-eng/askamex-couchbase-sdk)",
            "There's a lot of space to make some really neat stuff here, especially because Kotlin's type engine is probably one of the best (most definitely the best on the JVM). I know there are delivery constraints, which is why I didn't want to block the ongoing work, but I did want to at least put some ideas forward so maybe we can keep things in mind as we get bandwidth to tackle them."
        ]
    },
    {
        "27664": [
            "Left in on accident?",
            "Funny enough I saw this and am putting something together to show a first pass at \"how we might safeguard\" against this all-too-easy-to-make type of error",
            "Why are we returning `Outcome<String, String>` here? Meant to ask this before, what does the string represent?",
            "We duplicate this key creation quite a few times, can we extract it to a common extension function on a string, and then apply it to the `KEY_TYPE_PREFIX`? Something like below:\r\n\r\n```kotlin\r\nprivate const val PUBLIC_GUID_LENGTH = 32\r\n\r\nprivate fun String.toKey(guid: String): String: {\r\n    check(guid.length == PUBLIC_GUID_LENGTH) { \"Malformed Public GUID, length should be $PUBLIC_GUID_LENGTH, got ${guid.length}\" }\r\n    return \"${this}::$guid\"\r\n}\r\n```",
            "I think it's a bit deceptive, I don't know that it needs to be changes given it seems like we may take a closer look in general, I'm sure you can see what I'm saying",
            "Oh really? Curious on this, I was pretty confident on that, any links I can give a peek? "
        ]
    },
    {
        "27196": [
            "Agreed, we should preface all calls to key operations with some generalized `exists` evaluation, and then proceed with the actual operation"
        ]
    },
    {
        "27096": [
            "Something to add here, we could use sub-document operations, to avoid all of this.\r\n\r\nIt would simplify greatly the code, unless there's a good reason to avoid it for this use case I'd say it's definitely worth looking into at least.\r\n\r\n[Couchbase Docs](https://docs.couchbase.com/java-sdk/current/howtos/subdocument-operations.html) link for reference.",
            "I believe we should fail, else we are creating ambiguity in the underlying semantics of the operations, just to be clear.\r\n\r\nDefinitely fair @zsun3 may be overkill currently, though I think now's a good time (if we have the time) to plant seeds for when we find ourselves needing it. Not a sticking point for me though, mostly just trying to do some \"information pollination\" :) ",
            "Why not simply add an empty preferences document whenever we encounter a missing document for a user? This will solve the \"second read\" issue, and semantically is consistent as each user should have some preferences (even if there are no values, the emptiness is still meaningful, ie. no custom preferences set). It has to get created at some point, so why not \"on-demand\"",
            "We could even just preface these flows with the below, so we can avoid the nesting of try-catch's\r\n```kotlin\r\nif (!couchbase.exists(\"$prefDocumentKey\")) { createDocument(\"$prefDocumentKey\") }\r\n```",
            "Key operations are incredibly performant for couchbase, I've worked with it extensively, I can't imagine in even the most absurd key-operation scenarios that you'd place any meaningful strain through this"
        ]
    },
    {
        "26998": [
            "Can we split this into another test method? So we have proper segmentation of tests, and these are ultimately unrelated",
            "I would expect two tests, like below, just for reference\r\n\r\n```kotlin\r\n@Test\r\nfun `getDocument returns null when document not found`() {\r\n    coEvery {\r\n        mockPrimaryClusterOperation.read(\"moblPref::guid\")\r\n    } throws DocumentNotFoundException(SearchErrorContext(null, null, 400, null))\r\n\r\n    val response = runBlocking {\r\n        subject.getDocument(\"guid\")\r\n    }\r\n    assertThat(response).isEqualTo(Outcome.success(null))\r\n}\r\n\r\n@Test\r\nfun `getDocument returns expected document when the key is present`() {\r\n    coEvery {\r\n        mockPrimaryClusterOperation.read(\"moblPref::guid\")\r\n    } returns realGetResult as GetResult\r\n\r\n    val response = runBlocking {\r\n        subject.getDocument(\"guid\")\r\n    }\r\n\r\n    assertThat(response).isEqualTo(Outcome.success(CustomerPreferences(flags = mapOf(\"flag1\" to true, \"flag2\" to true))))\r\n}\r\n\r\n```",
            "Nit: Naming on this is unusual, see below suggestions\r\n```suggestion\r\n        val response = runBlocking {\r\n```\r\n\r\nApply below as well"
        ]
    },
    {
        "26719": [
            "I was thinking completeness of enforcement for the array of results , per the contract. It's more fragile, but will fail in all cases where we get the invalid result, which I think could save some debugging pains in the case where it occurs",
            "I was thinking completeness of enforcement for the array of results , per the contract. It's more fragile, but will fail in all cases where we get the invalid result, which I think could save some debugging pains in the case where it occurs",
            "lol, i have no idea how this got here, but removed"
        ]
    },
    {
        "26704": [
            "We're not sending API Key or JWT for Phase 1, per today's alignment"
        ]
    },
    {
        "26666": [
            "Fixed",
            "Fixed",
            "Yeah, this was intended for chat context stuff, wasn't it?"
        ]
    },
    {
        "26633": [
            "We handle these, as we use the `OkHttpBuilderProvider.get().build()`, to get the `OkHttp` client, and we get the `CustomProperties` directly. We don't need the Guice module obviously ",
            "We're using much more than just GUID, see [core usage here](https://git@github.aexp.com/amex-eng/m1-msl/blob/6a9e2102380b9f68620a9bb425a577bc698c9b73/backend-service-clients/search/contextual-search/src/main/kotlin/com/americanexpress/mobileone/bsc/contextual/search/ContextualSearchMapper.kt#L22-L28).",
            "Added!",
            "I don't think it's even a nit honestly, definitely important for observability",
            "It would serialize to `SEARCH` otherwise, which wouldn't be in the enumerated values for this attribute per the contract. \r\n\r\n[Here's the contract for reference](https://github.aexp.com/pages/amex-eng/askamex-contextual-bots/)",
            "These are applied, as `OkHttpModule().provideOkHttpClientBuilder()`  is called, which is the same as the typical Guice method. Method call below for reference:\r\n```kotlin\r\n    @Singleton\r\n    @Provides\r\n    fun provideOkHttpClientBuilder() = OkHttpClient.Builder()\r\n        .callTimeout(timeOutMillis, TimeUnit.MILLISECONDS)\r\n        .eventListenerFactory(DnsListenerFactory)\r\n        .addNetworkInterceptor(OkHttpTraceInterceptor())\r\n        .addNetworkInterceptor(OkHttpLoggerInterceptor())\r\n        .retryOnConnectionFailure(false)\r\n        .connectionSpecs(okHttpConnectionSpecs)\r\n\r\n```",
            "Added",
            "Created https://jira.aexp.com/jira/browse/M1-151289",
            "Updated",
            "We aren't using Guice, but @xhuan9's template for a DI-free approach (similar to streaming)",
            "Added",
            "Added",
            "Added",
            "Updated!",
            "This means basically, that there is a type of `chat_suggestion` that only has `text.display` and `text.message`, and that we get no additional context block to send. \r\n\r\nWe may not even get this, as we can get an empty array of `chat_suggestions` regardless.",
            "Updated",
            "Adding this now",
            "Ahh nice, quiet change from backend, okay will update",
            "I added support for this",
            "Can I add this as a fast follow? This change set is large honestly, and want to get this into `main` so we can start validating connectivity"
        ]
    },
    {
        "26553": [
            "yeah sure"
        ]
    },
    {
        "26509": [
            "@fsudeepk made this change, I think it was to handle some client capability issues yesterday, but unsure",
            "Adding this now",
            "It's sync'd on main right? So we could do so after merging"
        ]
    },
    {
        "26330": [
            "Yeah, no `feedbackId`"
        ]
    },
    {
        "26117": [
            "Yeah we can, I can close this out, mostly just wanted to show"
        ]
    },
    {
        "26097": [
            "These endpoints should be updated to match what's merged in the contracts repository, [link here](https://github.com/amex-eng/m1-api-contracts/pull/4725/files#diff-895cdb80b22b402682a16df24ece7102cfc9c27f7d1f6522a1af0529a700ea21)."
        ]
    },
    {
        "26081": [
            "@vdharma caching is missing some parameter that seems to be throwing some error:\r\nTop level initialization failure:\r\n`at com.americanexpress.mobileone.caching.CacheManagerImpl$responseFromCache$1.invoke(CacheManager.kt:158)`\r\nCaused by below NPE:\r\n```\r\nCaused by: java.lang.NullPointerException: inStream parameter is null\t\r\n\tat java.base/java.util.Objects.requireNonNull(Objects.java:233)\t\r\n\tat java.base/java.util.Properties.load(Properties.java:407)\t\r\n\tat com.americanexpress.mobileone.caching.CachePoolConfig.<clinit>(CachePoolConfig.kt:35)\r\n```"
        ]
    },
    {
        "25918": [
            "Correct, which is the only time we need to worry about sending the error response back to the client (unless I'm missing something)"
        ]
    },
    {
        "25854": [
            "Personal Pref/Super Nit:\r\nI would extract this to a function, with the client `Claim` type as the receiver. ",
            "Same as above comment",
            "Again, still super nit-ty but wanted to raise",
            "Okay sounds great!"
        ]
    },
    {
        "25674": [
            "I just added the direct import so it matched the style of the other capabilities"
        ]
    },
    {
        "25580": [
            "Yes, but via mobile tools ramp-up UI, per @rgrondin's request",
            "Updated here, nice catch, let me know if these most recent changes make sense",
            "I'm dumb"
        ]
    },
    {
        "25455": [
            "Won't do as backend fixed the issue which was causing the need for this"
        ]
    },
    {
        "25355": [
            "Are these conditionals right? I would assume `Scheduled` would be `Recurring *`, no?\r\n\r\nAlso, can we enumerate these? String matching is fragile",
            "Same as [above](https://github.aexp.com/amex-eng/m1-msl/pull/25355/files#r2327235)"
        ]
    },
    {
        "25347": [
            "Yeah I was thinking about this, but decided to follow the reference, good to know, I'll add these changes",
            "Ahh nice reference",
            "Yeah, this is unclear reading it back again",
            "Agreed on this",
            "Yeah definitely, I followed reference a little too closely it seems \ud83d\ude05 ",
            "Yeah, I definitely agree, I've updated"
        ]
    },
    {
        "25304": [
            "What are the units for `Daily Volume`?"
        ]
    },
    {
        "25275": [
            "I have another commit which will follow on, this is just the cherry-picked commits which had green builds. Not sure what's causing the issues, else I would. Is it okay if I follow-up directly after this one with the set of internal changes?"
        ]
    },
    {
        "25257": [
            "> @amichn , is it possible to break up this PR into a few, grouped by change\r\n\r\nA lot of these files are due to the addition of `internal`, and due to the highly polymorphic nature of this set of models breaking them up would be a decent amount of effort. \r\n\r\nThe prior pull request #25130 did have approvals already, but for some reason it would hang indefinitely on CICD. Still unsure why, but the recreation of the pull request was just to try and circumvent the build issues. I also have stacked changes on top of this which will already be a decent amount of work given how long this one has been alive. Breaking it up will make the stacked changes much more challenging to integrate smoothly and without a good bit of effort.\r\n\r\n[Stacked changes for reference](https://github.aexp.com/amex-eng/m1-msl/compare/feature/M1-147058-feature-layer-composite-models...feature/M1-145606-valgen-feature-layer-normalizers?expand=1)"
        ]
    },
    {
        "25130": [
            "Updated all of these, going to resolve them all",
            "Unsure why this branch refuses to build, pushed a new commit + pulled main, if this doesn't resolve I'm going to try opening a new pull request to see if that helps at all"
        ]
    },
    {
        "25031": [
            "Sadly no, as it's an integer, not a string, so deserialization will fail.",
            "No, they haven't. [Here's a query](https://ecpsplunk-e2.aexp.com/en-US/app/m1-msl-websockets/search?sid=1697208727.8384605_E056EC1E-C41F-4673-A6B6-4F8B68BF42D5) to show the amount of instances of `len(text) > 1` , and [here's another](https://ecpsplunk-e2.aexp.com/en-US/app/m1-msl-websockets/search?sid=1697208806.8384862_E056EC1E-C41F-4673-A6B6-4F8B68BF42D5) showing the actual text itself.\r\n\r\nThis should definitely be clarified, I'll open a subtask for that (and changing this behavior).",
            "I've created [M1-146772](https://jira.aexp.com/jira/browse/M1-146772) to track this @rgrondin ",
            "Added this, definitely definitely an improvement!",
            "Added these, they're technically covered at the top level, but better to not be loose w/ these given it's chat",
            "Added as well"
        ]
    },
    {
        "24986": [
            "Headers will give us visibility into the traffic going to the search sources, where as parameters aren't logged in production"
        ]
    },
    {
        "24875": [
            "These are all transient, as we don't want to actually read in an `object` when coming the JSON tokens. We are effectively transposing this into an array, hence the `... : Iterable<ApiCompositeComponent>`.\r\n\r\nThe hard-coding for the `componentId` isn't the most pretty thing, but it's the best I could come up with while still having this adhere to `ApiCompositeComponent`. I'm open to thoughts on that"
        ]
    },
    {
        "24827": [
            "Yeah this is a good point actually, let me make this change",
            "Change made!"
        ]
    },
    {
        "24767": [
            "Yeah they can, I was actually planning on going through and making a set of updates that set all relevant `Api*` models to internal, as to not expose them to the feature layer. \r\n\r\nAre you okay w/ me including these mapper functions in that? These would be errors at that point anyways, as the class the function is extending is internal anyways. It being easier to review if they are grouped together was my thinking on holding off on it."
        ]
    },
    {
        "24669": [
            "Okay, let me add those real quick",
            "Going to be raising in a fast-follower pull request, just to avoid growing this any larger"
        ]
    },
    {
        "24662": [
            "This doesn't need to be wrapped in a `try { ... }` like the `v1` version, right? Approving, but just wanted to confirm this was intentional"
        ]
    },
    {
        "24635": [
            "The reason I didn't is due to us having a `Map<String, ApiMessage>`, where if we don't have `ApiMessage` as a super-class with the function `toClientMessage` then we'd need a full `when` statement for this type handling. I kept the rest of the mappers inside the message scopes subsequently, just for consistency. I'm totally willing to move the `content` (and other non-\"top level message\") mapper functions to a dedicated file if that's preferable, but I think removing this polymorphism on the BSC transformation level doesn't make a lot of sense. It keeps the code logically in line with the `PolymorphicJsonAdapter`, as well as adhering well to the semantics of the underlying data being processed.\r\n\r\nExample of one immediate impact of not having `<T extends ApiMessage> T.toClientMessage()`:\r\n```kotlin\r\nmessages.map {\r\n  when (message.type) {\r\n    is ApiMessage.Type.TEXT -> message.toClientMessage()\r\n    is ApiMessage.Type.SINGLE_CHOICE -> message.toClientMessage()\r\n    // ...\r\n  }\r\n}\r\n```"
        ]
    },
    {
        "24585": [
            "Resolved this, though the smaller lifecycle change in `ConversationClientTest` is required in order to not have the shared `backendServer` have flaky queueing of responses."
        ]
    },
    {
        "24453": [
            "Super nit, but I think this should be `No` , with the link included but the disclosure of how inaccurate/incomplete we know it to be. Just for people who may not be familiar with chat who may read this document",
            "These seem very very low"
        ]
    },
    {
        "24450": [
            "Are these correct? Numbers don't really match up"
        ]
    },
    {
        "24287": [
            "Typo here in DINNING",
            "Typo "
        ]
    },
    {
        "24268": [
            "Both parameters have value `type`, guessing it should be updated to `query`?\r\n\r\n```suggestion\r\n        @Query(\"query\") query: String,\r\n```"
        ]
    },
    {
        "24238": [
            "Do we know that they won\u2019t send null values for keys? They do that occasionally"
        ]
    },
    {
        "24027": [
            "Would we hope they update to something like `/countries/v2`? I think we should try to discourage the inclusion of the protocol operation in the path itself where possible",
            "Can we use the headers from the common `ServiceHeaders.kt` where possible? \r\n`Authorization` is one example ([link to code](https://git@github.aexp.com/amex-eng/m1-msl/blob/ecd678fdab2aa9ea963b7eab7583a46770db57d2/backend-service-clients/bsc-common/src/main/java/com/americanexpress/mobileone/bsc/common/ServiceHeaders.kt#L31))"
        ]
    },
    {
        "23808": [
            "Copy, removed!",
            "Okay, I've removed"
        ]
    },
    {
        "23760": [
            "\ud83e\udd26 oops"
        ]
    },
    {
        "23571": [
            "Is there a reason for this abstraction? Our reference implementation for feature layer normalizers ([`ReferenceImplementationNormalizer`](https://git@github.aexp.com/amex-eng/m1-msl/blob/fd017dda355012ed1446201bfad9b6052e31ca28/features/reference-implementation/src/main/java/com/americanexpress/mobileone/referenceimplementation/ReferenceImplementationNormalizer.kt#L12)) doesn't abstract out to an interface, and I can't see any compelling reason here.\r\n\r\nIf there isn't one I would advise simplifying it to just the implementation",
            "This filename should be `DeleteTokenFakes.kt`. You can reference [`ReferenceImplementationFakes.kt`](https://git@github.aexp.com/amex-eng/m1-msl/blob/fd017dda355012ed1446201bfad9b6052e31ca28/features/reference-implementation/src/test/java/com/americanexpress/mobileone/referenceimplementation/test/support/ReferenceImplementationFakes.kt#L1-L0)"
        ]
    },
    {
        "23432": [
            "> We have to enable these markets in their[ respective yaml files as well](https://github.aexp.com/amex-eng/m1-msl/tree/bd6514e750cf2a370c58a2e518a3e716c92b5e40/common-resources/src/main/resources/config/capabilities/account). This is interim till move completely ECM.\r\n\r\nJust added!"
        ]
    },
    {
        "22808": [
            "This `when { ... }` is superfluous, we can do the below:\r\n```suggestion\r\n            val isNeededPointsTotal = physicalSection?.costLabel != \"Free shipping\" ?: false\r\n```",
            "Nit:\r\nPersonally I don't like binary `when`'s and normally default to using an `if`\r\n```suggestion\r\n                    pointsTotal = if (isNeededPointsTotal) pointsTotal else \"\"\r\n```"
        ]
    },
    {
        "22744": [
            "Unsure as to why this was changed, and my default is towards stronger types, even more-so when working w/ enumerated values. Is there any context on this?",
            "I'd even recommend using an [`EnumMap`](https://docs.oracle.com/javase/8/docs/api/java/util/EnumMap.html)."
        ]
    },
    {
        "21873": [
            "Checking with team right now, this is a good point",
            "@rgrondin this is updated with what we discussed, please give it a check when you have a moment!"
        ]
    },
    {
        "20747": [
            "This was required as I'm post-fixing the `PLAN_DETAILS` and `PAY_IT_DETAILS` elements to the \"optimized\" version of the extended transaction details request attributes. Just a simple re-ordering"
        ]
    },
    {
        "20269": [
            "Yes, I did thorough log analysis for this of AskAmex logs. \r\n\r\nNot sure if you have DDPD log access, but [this is the query](https://ddpdsplunk2.aexp.com/en-US/app/Amex_C3IP_V2/search?sid=1681398180.17121_B45DF2B1-E4DE-4402-A438-7F5749DFAD4E) which I created to validate this.",
            "I actually intentionally used an object, to try and communicate its' \"singleton-ness\". I'd be curious to know why you would prefer `val`?\r\n\r\nI'm not opposed, I just can't think of anything. My motivation for using an object declaration was simply feeling like it was more clear in [`ConversationApiAdapter.kt`](https://github.aexp.com/amex-eng/m1-msl/pull/20269/files#diff-360a7a13e9cb9d5b936e32c8c4e6dbcbfe118e0418e3853a5b0b167e5ecf7f22R12) that we were using a declared instance of an adapter, as opposed to a potentially calculable/dynamic `val`.",
            "Good point, I do have coverage in [`ConversationApiMessageModelTest.kt`](https://github.aexp.com/amex-eng/m1-msl/pull/20269/files#diff-1d06291b437ccd34dcba2273863bfa54bc23868b9ca6b18515a41581a9669d93R54-R58) but explicit, \"fine-grain\" tests for these are definitely a habit I should be building. \r\n\r\nAdding this now!",
            "This is logs for new message creation, sorry, that wasn't clear in my message. Let me see real quick if I can pull out conversation history logs real quick to make it more transparent."
        ]
    },
    {
        "20183": [
            "It was causing the test to fail, because the app version is set to `6.24.0` in this test, and the `minimumSupportedVersion` for this is `6.64.0`. I did update the `appVersion` in the test, but it caused lost of failures, so I simply removed this for the time being. "
        ]
    },
    {
        "20001": [
            "Shoot that's right, let me update that"
        ]
    },
    {
        "19917": [
            "This is mirrored from the API, and while it may not be a \"must have\", it creates more strict, semantically rich, and accurate bounds for the backend API models, which is the whole driver of this initiative. \r\n\r\nWe currently have 0 contract provided by the backend team, so any and all schema restraints we can add with high certainty are of the utmost value, in my opinion.\r\n\r\n[Here's where we using this for deserialization](https://github.aexp.com/amex-eng/m1-msl/blob/e138032b6a55f8316ba5d2fbba062820cddaf7d4/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/ConversationApiAdapter.kt#L97-L101), in the API response processing, where it's definitely a good idea in my view.",
            "Will update both this model & the API model!",
            "Ahh good point, let me remove these"
        ]
    },
    {
        "19448": [
            "Great point, updating this!",
            "\ud83e\udd26 yup, I'm dumb",
            "@rgrondin a null response is definitely an error scenario, to be clear. I avoided touching the legacy BSC because I didn't want to create any risks for the wider conversation history functionality (though it shouldn't, but that's been said at least once before every production outage ever \ud83d\ude05). The new BSC for conversation history is accurate here, I've just avoided changing this in the legacy one to avoid the potential of issues as mentioned above.",
            "I didn't know that was possible (referencing the M1 API Contract JSON response payload), really neat, adding this now!"
        ]
    },
    {
        "19435": [
            "Nit:\r\nAs we're only passing in 3 headers, personally, I think naming them here makes a lot of sense. [Here's an example](https://github.aexp.com/amex-eng/m1-msl/blob/35e93051ddd60f79197d9176f1fafe68971fdf1e/backend-service-clients/reference-implementation/src/main/java/com/americanexpress/mobileone/bsc/referenceimplementation/ReferenceImplementationApi.kt#L28-L33) of what I mean from the `ReferenceImplementationApi`",
            "Another Nit:\r\nPersonally, if there's just 1 version in the code, I don't see a reason to explicitly declare `V1`. It's implied, and we can always add `...V{N}` to subsequent versions as required. ",
            "I see these are nullable in [the contract](https://explorer.aexp.com/functions/ReadBankingMoneyTransferEligibility.v1), but do we actually want them to be? Typically, I'm a fan of an explicit default behavior (and non-nullable parameter) wherever it makes sense. It makes it more clear when reading code, and protects us if the backend changes the \"default\" behavior for a nullable parameter without notifying us.",
            "This isn't required, you can reference the [`ReferenceImplementationClient`](https://github.aexp.com/amex-eng/m1-msl/blob/main/backend-service-clients/reference-implementation/src/main/java/com/americanexpress/mobileone/bsc/referenceimplementation/ReferenceImplementationClient.kt) to see the \"general case\" approach for BSC's!\r\n\r\n```suggestion\r\n```",
            "This logger call, can also be removed! \r\nAlso a nit on formatting:\r\n```suggestion\r\n        ).execute().map { it.body.toClientResponse() }\r\n            .mapError { it.toClientErrorResponse() }\r\n```",
            "Nit/Personal Preference: Small change here, to avoid having to manually enumerate all of the `GenericError` instances.\r\n\r\n```suggestion\r\n    when (this) {\r\n        is ApiCallError.HttpError.ServerError -> RetryError(debugMessage)\r\n        is ApiCallError.GenericError -> genericErrorResponse\r\n        else -> GenericError(debugMessage)\r\n    }\r\n```",
            "Style:\r\n```suggestion\r\n    get() = if (e is IOException) RetryError(debugMessage) else GenericError(debugMessage)\r\n```",
            "This may be the case if it's not a sealed interface, but in this scenario, `ApiCallError` (and all children) are already enumerated implicitly, as a result the sealed interface definition. Effectively, we've already manually enumerated the possible cases [here](https://github.aexp.com/amex-eng/m1-msl/blob/7fda2bf7f606ffaa1c223aa2a96a647647cf53aa/backend-service-clients/bsc-common/src/main/java/com/americanexpress/mobileone/bsc/common/retrofit/ResultAdapter.kt#L64), so repeating it in this code doesn't give us anything additional, except for more code to maintain.\r\n\r\nWorst case, we'd still have functionally the same visibility, as we're still passing the `debugMessage`, and if it's a net-new failure, we will always have some impact, as we're not yet handling the new \"special case\". Let me know if this makes sense or not!"
        ]
    },
    {
        "19432": [
            "Super Nit:\r\nMaybe we can consider as a follow-up removing the `V2` postfix from the code, as it'll be the only version present. I think `...V2` would have me searching for the `...V1` personally, plus removing it makes naming a bit \"cleaner\". Just a thought though!"
        ]
    },
    {
        "19190": [
            "Yeah, I think this is best covered in the coming ticket M1-123338 slated for `1.99.0`"
        ]
    },
    {
        "19174": [
            "Nit:\r\nWhen we have a single annotation, we should be placing it on the same line as the declaration.\r\n\r\nReference: [Kotlin Coding Conventions - Annotations](https://kotlinlang.org/docs/coding-conventions.html#annotations)",
            "I won't duplicate this comment on all instances, but it should apply for all singlely-annotated data class constructor attributes, if you're making the change we should be consistent \ud83d\ude04 ",
            "Dang not sure how I missed that, thanks @rgrondin "
        ]
    },
    {
        "19004": [
            "Maybe a nit:\r\nI think it would be good to update `AmexConnectError` to be an enum, instead of a companion object w/ string constants. If we have enumerated error scenarios, we should make the clear in the code, and raw strings can lead to bugs in the future."
        ]
    },
    {
        "19001": [
            "Should we actually be doing this? This would result in a distance of unknown units being returned. This seems like we should consider if the absence here represents a failure (or maybe null-ing the entire distance data if that's supported?). Not 100% sure on the use case, just seemed a bit \"off\" to me."
        ]
    },
    {
        "18408": [
            "We shouldn't need these explicit enum names in Moshi.\r\n\r\nThis is also the case on line 77-84 (`TransactionChannelType`) ",
            "Can you include them in the code as a comment, so developers can easily access?",
            "No explicit name required for `operation` (as it's already provided by the parameter) when using Moshi."
        ]
    },
    {
        "18294": [
            "Yeah definitely not, removing this",
            "Bit of an issue, as we don't have extensive `expectedResult` models. We likely need a story focused on more rigorous testing for this BSC/feature as a whole. I think adding this would be a good deal of work, and likely shouldn't be \"in scope\" for this story, but definitely want to take it up as it's critical to being able to say confidently that the code is healthy going forward."
        ]
    },
    {
        "18262": [
            "Nit: Acronym more than 2 letters, so should camel-case per [Kotlin Conventions](https://kotlinlang.org/docs/coding-conventions.html#choose-good-names)\r\n\r\n```suggestion\r\n        val transactionDetailsSoap: TransactionDetailResponse = finsProvider.getTransactionDetail(\r\n```\r\n",
            "Nit: Acronym more than 2 letters, so should camel-case per [Kotlin Conventions](https://kotlinlang.org/docs/coding-conventions.html#choose-good-names)\r\n\r\n```suggestion\r\n        val transactionDetailsRest = submitFinsRest(card, transactionId, billingCycleIndex, billingCycleDate)?.await()\r\n```\r\n"
        ]
    },
    {
        "18176": [
            "Good point, I think so, let me validate"
        ]
    },
    {
        "18159": [
            "A couple of notes. Right now there are compilation issues due to [this invocation of the construtor](https://github.aexp.com/amex-eng/m1-msl/blob/bbfab848bb94d9b365ee58f673b0f0dbb78825c3/backend-service-clients/financials/fins-service-onedata-client/src/test/java/com/americanexpress/mobileone/bsc/finsonedata/FinsClientImplTest.kt#L70-L77), though I don't think we need to change that file.\r\n\r\nThis is using the \"more modern\" cache, as it's underlying class is using `Outcome`, so it doesn't even need it as a constructor parameter. I'll propose changes in another comment",
            "```suggestion\r\n    ): Outcome<FinsError, List<StatementPeriodsClientResponse>> = ClientResponseCache.getOrUpdateCache(\r\n```\r\nWe can access the globally scoped instance here without any concerns",
            "This will enable us to not have to do the updates to the constructor parameters either (resolving the compilation issues too)",
            "```suggestion\r\n```\r\nCan remove this"
        ]
    },
    {
        "18156": [
            "oooo I like it, means not having to pass any params, just wrapping the existing code in a lambda (for newer implementations)"
        ]
    },
    {
        "18151": [
            "@rgrondin I would, in a non-hackathon setting, advise something akin to how we're building `ConnectionId` keys for `m1-msl-streaming` (deferring to an optional lambda, [code is here](https://github.aexp.com/amex-eng/m1-msl-streaming/blob/main/ktor/app/src/main/kotlin/com/aexp/mobileone/ktor/app/websocket/WebSocketConnectionHandlersBuilder.kt#L18)). Avoided this just for simplicity honestly"
        ]
    },
    {
        "18090": [
            "Nit: \"_metadata_\" is one word, so variable should be `metadata`\r\n```suggestion\r\n    @Json(name = \"meta\") val metadata: AccountMetadata?\r\n```",
            "No need to have an explicit JSON name if it matches the parameter name when using Moshi\r\n```suggestion\r\n        val accountToken: AccountToken?,\r\n```",
            "No need to have an explicit JSON name if it matches the parameter name when using Moshi\r\n\r\n```suggestion\r\n    val assessmentToken: String,\r\n```",
            "No need to have an explicit JSON name if it matches the parameter name when using Moshi\r\n\r\n```suggestion\r\n        val customFacts: List<CustomFacts>?\r\n```",
            "No need to have an explicit JSON name if it matches the parameter name when using Moshi\r\n\r\n```suggestion\r\n    val challengeQuestions: List<ChallengeQuestionsV3>\r\n```\r\n\r\nI won't comment on any further instances, but these should be applied to all such instances. Let me know if you have any questions/concerns!",
            "Personal Preference: \r\nPersonally I like the explicit signature of `Challenge.ChallengeOption.Category...` but I can see the point of removing it. Up to you, but figured I'd comment on it."
        ]
    },
    {
        "17876": [
            "Yes, to be clear, it's required for any \"Mutate\" operations (create & edit), but it's optional for the \"get\" operations. This is the case for both the API & Client models",
            "I meant to include these, my bad, I've added them now!"
        ]
    },
    {
        "17859": [
            "Going to be remaking this, as the `UPDATE` function actually _does_ require the phone fields for the response. This will simplify it, but I don't want to waste peoples time w/ reviews waiting for that update. Apologies"
        ]
    },
    {
        "17556": [
            "Super nit: I likely would opt instead to use the lambda inside of `let` for the newline, as opposed to the nullable operator. Just a personal preference though, definitely not a \"must change\" \ud83d\ude05 \r\n\r\n```suggestion\r\n    override fun dispatch(request: RecordedRequest): MockResponse = urlToResponseMap.get(request.path)?.let { \r\n        MockResponse().setBody(it.body).setResponseCode(it.responseCode)\r\n    }\r\n```"
        ]
    },
    {
        "17531": [
            "**Nit/Personal preference:**\r\nPersonally I think I would probably write this to try and highlight the encapsulation present. That is, the enumerated values should only ever exist inside instances of `KnowYourCustomerRefreshData`. I'd write the code to try and make that \"pseudo-encapsulation\" transparent to people reading it. See the below for an example:\r\n```suggestion\r\ndata class KnowYourCustomerRefreshData(\r\n    val customerId: String?,\r\n    val deferrable: Boolean,\r\n    val dataElements: NonEmptyList<DataElement>\r\n) {\r\n    enum class DataElement {\r\n        ADDRESS,\r\n        DATE_OF_BIRTH,\r\n        INCOME,\r\n        NAME,\r\n        NATIONALITY,\r\n        OCCUPATION\r\n    }\r\n}\r\n```",
            "Same opportunity for encapsulation as the above comment.",
            "The [ReferenceImplementationClient](https://github.aexp.com/amex-eng/m1-msl/blob/35e93051ddd60f79197d9176f1fafe68971fdf1e/backend-service-clients/reference-implementation/src/main/java/com/americanexpress/mobileone/bsc/referenceimplementation/ReferenceImplementationClient.kt#L39) opts to use a [`{Name}Mapper`](https://github.aexp.com/amex-eng/m1-msl/blob/35e93051ddd60f79197d9176f1fafe68971fdf1e/backend-service-clients/reference-implementation/src/main/java/com/americanexpress/mobileone/bsc/referenceimplementation/accounts/AccountsMapper.kt#L15-L30) to convert from the API response model to the client response model. \r\nI think doing the same here would greatly improve the readability of the file, while also extracting relatively straightforward (but important) logic, thus allowing for more maintainable testing over the mapping functionality.",
            "This would also fit better in a dedicated `Mapper` file in my opinion."
        ]
    },
    {
        "17494": [
            "Do we need this explicit `@JsonClass(generateAdapter = true)`? \r\nI believe, as long as you're registering the `KotlinJsonAdapterFactory()` (which you are) data classes should be good to go.\r\n\r\n```suggestion\r\n```",
            "Nit:\r\nThis annotation is unnecessary. I can understanding wanting to annotate all elements for consistency, but I think it just adds another possible statement that can cause headaches personally, so I'd probably opt to not include it, but it's not a big deal regardless.\r\n\r\n```suggestion\r\n        val nonce: String,\r\n```"
        ]
    },
    {
        "17493": [
            "Super nit:\r\nI think pluralizing the filename helps readability a tiny bit. So instead of `CreditLineLoanApiModel` it would be `CreditLineLoanApiModels`. The reference implementation actually has it both ways ([plural version](https://github.aexp.com/amex-eng/m1-msl/blob/a417f72e4148e7755b3b4cb89e374ee57c858ab9/features/reference-implementation/src/main/java/com/americanexpress/mobileone/referenceimplementation/ReferenceImplementationModels.kt) and [singular version](https://github.aexp.com/amex-eng/m1-msl/blob/a417f72e4148e7755b3b4cb89e374ee57c858ab9/backend-service-clients/reference-implementation/src/main/java/com/americanexpress/mobileone/bsc/referenceimplementation/benefits/BenefitsApiModel.kt)) but I think plural makes it clear there is more than a single model in the file personally.",
            "Nit:\r\n`code` isn't nullable per the contract [referenced here](https://explorer.aexp.com/functions/ReadCreditLineLoanPlans.v1)",
            "Super nit:\r\nI like using `TODO()` in intermediate pull requests like this. It has a reified return type, so it shouldn't give any error, but it has a unique highlight color so it's easily visible in the IDE. Plus it will throw `NotImplementedError` if it's executed, so it makes it very hard to accidentally forget about.\r\n\r\n```suggestion\r\n            .map { TODO() }\r\n```",
            "Same \"pluralization\" nit from above",
            "Can we make this private? I see the test, but we can cover this functionality without any additional complexity by validating against the `CreditLineLoadClientError` returned from `toClientError()`. Exposing a function on the Api error type makes it a bit more unclear how we should use the mapper in my opinion. \r\n\r\n```suggestion\r\nprivate fun ReadCreditLineLoanError.toClientMessage(): String =\r\n    \"code: $code; message: $message\"\r\n```",
            "Nit:\r\nPersonally against explicit `this.(...)` when it's not necessary. I think it's cleaner without them personally.\r\n```suggestion\r\n        is ApiCallError.ErrorBodyDeserializationError ->\r\n            CreditLineLoanClientError.DeserializationError(debugMessage)\r\n        is ApiCallError.GenericError ->\r\n            CreditLineLoanClientError.GenericError(debugMessage)\r\n        is ApiCallError.HttpError.GenericError ->\r\n            CreditLineLoanClientError.GenericError(debugMessage)\r\n        is ApiCallError.HttpError.ClientError ->\r\n            CreditLineLoanClientError.HttpError.ClientError(response.body.toClientMessage())\r\n        is ApiCallError.HttpError.ServerError ->\r\n            CreditLineLoanClientError.HttpError.ServerError(response.body.toClientMessage())\r\n```",
            "[Link to open pull request for updating the reference implementation](https://github.aexp.com/amex-eng/m1-msl/pull/17496)"
        ]
    },
    {
        "17372": [
            "Are the `null`'s in this block due to us not having the genuine backend response? ",
            "Nevermind, I see the `// TODO` where we're calling this the second time now. "
        ]
    },
    {
        "17269": [
            "The properties are technically inaccessible via reflection by default, due to the synthetic getters/setters injected by Kotlin. At runtime we'll get permissions failures if we don't set it to accessible. Below is an example if we try to call the getter without marking the property as accessible first:\r\n```\r\njava.lang.IllegalAccessException: Class kotlin.reflect.jvm.internal.calls.CallerImpl$Method can not access a member of class com.americanexpress.mobileone.bsc.common.moshi.adapters.JvmInlineString with modifiers \"public final\"\r\n```",
            "I thought they couldn't but just learned they can. Let me see how many headaches a multi-constructor value class adds. Going through the actual specification for value class constructor rules now.",
            "[Here's a link to the Kotlin Lang value class specification](https://kotlinlang.org/spec/declarations.html#value-class-declaration). I think a safe bet is to use the primary constructor solely, and disregard any other constructors, as we can guarantee the primary constructor will be:\r\n1. Single value\r\n2. The type corresponding to the single backing field for the class\r\n\r\nI don't think enforcing the singularity of this constructor is worthwhile though, I'll remove that check and ensure we're only using the primary constructor (can validate based on parameter count)",
            "I added one in the last commit where I removed the single-constructor enforcer \ud83d\ude04  It's on line 116",
            "Yeah I definitely think that's a good idea once we can guarantee it won't impact anything",
            "For testing validation, we register \"manual\" adapters (which we know give valid output) and use that as the expected serialized values.",
            "Yeah I'm actually working on this, I'm dealing with one issue w/ type erasure when comparing the deserialized value to the original instance. Actually a really good suggestion, as I wouldn't have caught this without attempting this change. It's super edge-casey, only occurring on a value class with a value of `Map<*, (some \"complex object\")>`, but definitely a valid use-case I would have missed.",
            "**See below comment** _(leaving the rest non-strikethrough'd for readability around the original issue)_\r\n~~Okay, so sadly, I think this caused me to find an issue that isn't solvable.~~ \r\n\r\nEssentially, any value class, with a backing field which has a (or many) type parameters, is impossible to resolve. This is due to the type erasure that happens when we reflect into the constructor. \r\n\r\nFor example, if we had the class\r\n```kotlin\r\n@JvmInline\r\nvalue class InlineStringList(val value: List<String>)\r\n```\r\n\r\nInstead of deserializing the value to a `List<String>`, we will unavoidably end up deserializing to `List<*>`, as we get the type via the constructor, which would be returned to us (theoretically) as `Class<List<String>>` after we invoke `constructor.genericParameterTypes[0]`. The issue is generics any deeper than depth=1 are erased, for all JVM based languages, so we invariably end up with `Class<List<*>>` for the adapter type we lookup. \r\n\r\nI've added an enforcement of that constraint with my latest changes. It's not ideal, but I've racked my brain, and I've fully run out of talent when it comes to solving this. I'd be open to any ideas though of course if I'm missing anything.",
            "Scratch the above, I actually got it to work. Genuinely super proud of this solution. Got it working using the below\r\n\r\n```kotlin\r\nval constructor = type.rawType.declaredConstructors.first { it.parameterCount == 1 } as Constructor<*>\r\nval valueType = type.rawType.declaredFields[0].genericType\r\nJvmInlineValueClassAdapter(\r\n    constructor = constructor,\r\n    adapter = moshi.parameterizedAdapter(valueType.rawType, valueType),\r\n)\r\n\r\nfun <V> Moshi.parameterizedAdapter(\r\n    valueClass: Class<V>,\r\n    valueType: Type,\r\n): JsonAdapter<V> = adapter(valueType)\r\n```\r\n\r\nBecause we can guarantee a value class only has a single declared field, we can use that to obtain the constructor type (and thus the type we should adapt to). This somehow _isn't_ erased in the `Type` instance, and we can use that to retrieve the adapter (and enforce the type consistency via the erased-at-runtime type supplied by `Class<T>`). I've tried pretty hard to break this, but it's passing everything I can throw at it. \r\n\r\nI added some very rigorous checks in the tests as well, see below for how I'm able to assert confidently that this is indeed a solved issue:\r\n```kotlin\r\nactual::class.java.declaredFields.map { field ->\r\n    assertThat(field.genericType)\r\n        .isEqualTo(original::class.java.declaredFields.find { it.name == field.name }?.genericType)\r\n}\r\n```",
            "Just a small update, which is adding support for a value class with some computable properties (properties without a backing field).\r\n\r\nAn example of a class like this is below:\r\n```kotlin\r\n@JvmInline\r\nprivate value class JvmInlineString(val value: String) {\r\n    constructor(\r\n        baseString: String,\r\n        appendedString: String,\r\n    ) : this(baseString + appendedString)\r\n\r\n    val secondValue: Char\r\n        get() = value.first()\r\n}\r\n```"
        ]
    },
    {
        "17249": [
            "We actually know that there must be a single value in this array (in this context), as value classes are defined as having 1 and only 1 declared property",
            "Yeah good point, let me move this",
            "I got mangled somehow, I've recreated this on #17269 "
        ]
    },
    {
        "16880": [
            "~~I reformatted using the MSL spec but nothing changed \ud83d\ude48~~\r\nI'm dumb, fixing now"
        ]
    },
    {
        "16822": [
            "Yup \ud83d\ude05  fixed"
        ]
    },
    {
        "16672": [
            "Nit: Ideally (in my opinion) we'd factor constants like these out, as they're also referenced in the assertion in the `Choreo2BdaasConverterTest`, so we can actually meaningfully link the two contents together.",
            "Super nit: Personally would name this `ChoreoToBdaasConverter`"
        ]
    },
    {
        "16251": [
            "Yes, this was aligned (I believe in a discussion w/ @rgrondin , though I wasn't a part of this discussion). \r\n\r\nI do understand the concern though. CBIS guards against this by requiring an AppToApp JWT ([contract here](https://github.aexp.com/pages/amex-eng/IDaaS_cbis_2_apidocs/index.html#tag/User-Session-Management/paths/~1digital~1v1~1UpdateSessionLastAccessTime/post)). Is there anything similar we can use to ensure these requests are only permitted from Mobile clients (as well as from [m1-msl-streaming](https://github.aexp.com/amex-eng/m1-msl-streaming), which will be the service where the websockets will be invoking this endpoint in order to refresh a connected mobile client's token)",
            "Updated this to move that there!",
            "We are sending it back, to indicate to clients if the token is either `INVALID` or `EXPIRED`. This is transforming the `200` but `INVALID` or `EXPIRED` into a `500` and indicating the server error which caused this (trying to keep in line w/ how most MSL API's treat these scenarios as best as I understand it)",
            "I have an open thread w/ the CBIS team on this. I did an analysis and posted in that thread, but we're seeing this elements on all `200 - OK` responses in the weeks data I sampled. [Link to that thread here](https://aexp-mobile-and-web.slack.com/archives/C31P4J8BV/p1665076626630329)",
            "This makes sense, though I want to be clear, mobile apps currently won't be the exclusive consumers here, there will be one other (and it will be the primary consumer), which is the [M1-MSL-Streaming](https://github.aexp.com/amex-eng/m1-msl-streaming) service we are using to implement websockets. \r\n\r\n@ppeetham do you have any guidance on what type of approach I should use to control access to this endpoint, such that we can ensure only the intended clients are able to refresh sessions?"
        ]
    },
    {
        "16203": [
            "Yup, this is me still learning the account/card capability ropes \ud83d\ude05 removed!",
            "I've fixed this now, definitely right on it failing tests \ud83d\ude05 "
        ]
    },
    {
        "16133": [
            "Any specific reason we're disabling this test w/ this copy update?",
            "Shouldn't we just update the copy for the E2E test response payload [here](https://github.aexp.com/amex-eng/m1-msl/blob/main/features/autopay/src/test/resources/endtoend/review/Review-en-US-GET-v1-200-success.json#L62)"
        ]
    },
    {
        "16128": [
            "Not super clear on this use-case. Could we not use a ramp-up config or feature enablement to federate this?",
            "Your comment on the same section didn't render in the code review panel for some reason. Makes a bit more sense, though I would question breaking with the established process for MSL."
        ]
    },
    {
        "15597": [
            "Removed! Missed this yesterday somehow \ud83d\ude05 "
        ]
    },
    {
        "15353": [
            "@zsun3 does this serve as a useful example, or should I share include one as a JavaDoc? I think the latter just so usage is clear to potential users",
            "Added some useful docs I think, let me know if there's anything left unclear that I should add!"
        ]
    },
    {
        "15351": [
            "Is there something preventing us from just not making the parameter `transactionSequenceNumber` nullable in the function signature?",
            "This whole this is 10000% a nit, just to be clear, don't want to make this out to be something worth not merging over, it's just another way of writing the same functionality.\r\n\r\nThat said, I went and checked out this code, and put something together which I think may be worth considering. I wanted to avoid the call to `requireNotNull` purely due to the reassignment that happens. Let me know what you think:\r\n```kotlin\r\noverride fun getPlanOptions(\r\n    accountToken: AccountToken,\r\n    id: String,\r\n    date: String,\r\n    transactionSequenceNumber: String?,\r\n): Outcome<PlanOptionsError, PlanOptionsResponse> = when (transactionSequenceNumber) {\r\n    null -> Outcome.error(PlanOptionsError.PlanOptionsBackendError(errorMessage = \"transactionSequenceNumber is null.\"))\r\n    else -> Outcome.sequential {\r\n        val (optionsResult) = optionsProcessorCommon.getPlanOptions(\r\n            accountToken = accountToken,\r\n            id = id,\r\n            date = date,\r\n            transactionSequenceNumber = transactionSequenceNumber\r\n        )\r\n        val terms = termsNormalizer.termsAndConditionsLinkTerms()\r\n\r\n        optionsNormalizer.normalize(optionsResult, terms)\r\n    }\r\n}\r\n```"
        ]
    },
    {
        "15339": [
            "It should be able to leverage `JsonInlineValue<T>` without issue, let me put together a quick example to be sure (only concern is w/ the list), tests don't include iterables currently.",
            "It can't currently, let me see if I can raise a pull request to include iterables to this",
            "+100000"
        ]
    },
    {
        "15310": [
            "Yeah I actually felt it was a bit trivial when writing, but was following another PR's structure. I do agree though, I'm going to remove this, let me know if any issues with that @fsudeepk ."
        ]
    },
    {
        "15251": [
            "Do we know the copy is going to be the same? I figured not, so I wanted to leave it as this to simply validate integration, and spend less effort given we have to fix the labels anyways in the future"
        ]
    },
    {
        "15201": [
            "Yeah it is sadly, as this `MASK_CHARACTER` is a `Char` , which is useful for the phone mapping as we iterate through the char array."
        ]
    },
    {
        "15135": [
            "Nit: I feel like this comment doesn't add much, I don't think it's needed personally"
        ]
    },
    {
        "15084": [
            "We're not masking the country-code prefix (or the `+` either)",
            "Sorry, hiccup running tests locally meant it showed passing but wasn't, resolved now, apologies"
        ]
    },
    {
        "15023": [
            "nit:\r\n Having the label assertions in here creates a dependency if we change the labels. Can we instead check if it's not empty?"
        ]
    },
    {
        "15017": [
            "These are all just whitespace changes to be clear (formatter made them, can revert though I think it looks cleaner this way actually)",
            "Ahh it didn't highlight the range for some reason, this was meant to be from line 43 through the end",
            "All changes below this comment in this file are just whitespace changes, to be clear. They were auto-applied when I formatted and I liked the changes, so I kept them.",
            "Wasn't aware of the `mapNotNull` functionality, really like this"
        ]
    },
    {
        "15000": [
            "Given we have `title` on line 38, should we be using that on line 36 as well? Not sure on this exact code but figured I'd ask"
        ]
    },
    {
        "14806": [
            "Yeah I wasn't sure as the `TransactionId` is in commons, but I think it's good not pollute commons looking at this now with fresher eyes",
            "Here's a link to the [Kotlin Language Coding Conventions section on trailing commas](https://kotlinlang.org/docs/coding-conventions.html#trailing-commas), which is what convinced me to use them. Personally I think they're a good idea, would be curious to hear what downsides there are from your perspective (truly, mostly because I am struggling to come up with any, but I by no means think that there's zero chance I'm missing something \ud83d\ude05)",
            "Man oh man, I keep making this mistake and it's driving me crazy. Understood though, let me take that approach",
            "The null check isn't actually adding anything here. \r\nTake some `transactionType` which is null, the conditional `TransactionType.DEBIT.equals(transactionType)` will always be `false`, so the `transactionType != null` is superfluous.\r\n",
            "The reason I didn't do this is because quite a few people are using `TransactionId` (63 usages), so it felt pretty risky to make that change inside of the base `TransactionId`. Knowing that, would you still look towards using this `@JsonValue`? I'm totally open to both, and would trust your judgement here, especially for potential impacts to the wider codebase.",
            "Yeah this is definitely a good change, just did this!",
            "I just did the refactor for that, let me know your thoughts. Had to touch quite a few files but I think it's a fairly tidy solution",
            "I ran into some non-trivial issues, I'd like to get this PR moved along, though I'm more than happy to do this as a follow-up if you'd like.",
            "Closing this and reopening under #14968 . I made a mistake when trying to rebase, and pushed on accident, creating 70 changed files and a headache in general. Apologies"
        ]
    },
    {
        "14686": [
            "Nit: Indentation is off here, should match the `accountFeaturesSignAndTravel` indentation",
            "Nit: Could re-use this list for both `accountFeaturesSignAndTravel` and `accountFeatureSelect`. "
        ]
    },
    {
        "14645": [
            "Yeah this is for the full conversation history model (courtesy of @asyed14). This is new coverage, and the inclusion of this model means it's deserializing the entire `ConversationApiResponse` payload, not just the additional fields. Apologies, definitely unclear from my side, too \"inside\" this code the past week or so and let too much info exist implicitly.",
            "This is for conversation history, we have some examples, but we're using this to work towards being able to create usable models for the RAML subtree going forward. If it looks like an anti-pattern, it's because it is, but we're left with little choice if we want to actually improve how we handle chat. It's definitely not an ideal position, but within the next 2 weeks as we iterate on this model I'm going to be migrating this data to that subtree, once I can provide a model which I'm thoroughly confident in.",
            "This is also the BSC response payload to be clear, not the MSL feature endpoint response (though currently they're very very similar, only 3 fields different between them)"
        ]
    },
    {
        "14559": [
            "This null-safe adapter wrapper is required due to how the `UnsureJsonNode` wrapper functions. I actually spent a good amount of time (too much if I'm honest lol) trying to avoid this, but wasn't able to get it working. Internally, all this null-safe adapter is doing is checking if the value is null, and if so writing a null value, else it delegates the Json operation to the adapter passed in during initialization (`JsonInlineAdapter` in this case)"
        ]
    },
    {
        "14469": [
            "Not required, I'm just doing this to making creating test data easier, else we have like 20 fields for each object."
        ]
    },
    {
        "14454": [
            "Is this comment leftover or intentional?"
        ]
    },
    {
        "14452": [
            "Yeah, long term this code should get deleted, it represents the inclusion of anti-patterns in BSC providers. Because we have no schema provided by the BSC provider we have to be very, very gentle in order to insure we're not breaking anything.\r\n\r\nIf there's a better approach to this I'd be 1000% open to hearing it. This has been an exercise in \"as least bad as possible\" which is... yeah lol..."
        ]
    },
    {
        "14432": [
            "Halfway nit, but can we make this a property instead? \r\n\r\nMy go-to is method for generated/created values (like UUID's etc.) & value for these types of static values. Definitely don't think it's without downside, and won't say there aren't cases where I don't break that rule, but it's my general rule of thumb (just personally).\r\n\r\n```suggestion\r\ninternal val RequestContext.mapHeaders: Map<String, String>\r\n    get() = mapOf(\r\n        ServiceHeaders.CONTENT_TYPE.headerName to APPLICATION_JSON,\r\n        ServiceHeaders.ACCEPT.headerName to APPLICATION_JSON,\r\n        ServiceHeaders.ONE_DATA_CORRELATION_ID.headerName to correlationId.id,\r\n        ServiceHeaders.ONE_DATA_CLIENT_ID.headerName to ServiceHeaders.ONE_DATA_CLIENT_ID_VALUE.headerName,\r\n        ServiceHeaders.AUTHORIZATION.headerName to authorization\r\n    )\r\n```",
            "While I understand the need for this generator, I don't know if this approach is solving it as completely as we could. Personally, I found it fairly challenging to grasp as first glance. \r\n\r\nAn alternative you might want to try could be something like what I've included below. You can obviously tailor the visibility modifier on the primary constructor to fit your needs. I've found this pattern really beneficial in the past personally. \r\n\r\n```kotlin\r\ndata class RequestContext private constructor(\r\n    val correlationId: CorrelationId,\r\n    val authorization: String\r\n) {\r\n    companion object {\r\n        operator fun invoke(appClientMetaData: AppClientMetaData) = RequestContext(\r\n            correlationId = CorrelationId(appClientMetaData.correlationID),\r\n            authorization = buildClaimsHeader(\r\n                authorization = AdminJsonWebTokenHolder.getA2aJsonWebToken().rawToken,\r\n                userAuthorization = appClientMetaData.jsonWebToken.rawToken\r\n            )\r\n        )\r\n    }\r\n}\r\n```\r\n\r\nThe usage would look like the below:\r\n```kotlin\r\nval tempLendingOfferRequest = LendingOfferClientRequest(\r\n    context = RequestContext(appClientMetaData),\r\n    accountToken = accountToken,\r\n    sourceCode = \"sourceCode\"\r\n)\r\n```",
            "Another benefit to removing this generator is reducing the required parameters",
            "Removing the generator also enables us to get rid of this.\r\n\r\nIf we wanted to extend for a test, all we'd have to do is remove the `private` from the primary constructor, and we could create what is effectively a \"constructor extension function\" to perform the same logic as above, like so:\r\n\r\n```kotlin\r\noperator fun RequestContext.Companion.invoke(authToken: String, appClientMetaData: AppClientMetaData) =\r\n  RequestContext(\r\n      correlationId = CorrelationId(appClientMetaData.correlationID),\r\n      authorization = buildClaimsHeader(\r\n          authorization = authToken,\r\n          userAuthorization = appClientMetaData.jsonWebToken.rawToken\r\n      )\r\n  )\r\n\r\n```",
            "I misspoke above, when I said \"static values\" I didn't intend it to be `static` like in Java, I meant constant references. As this `get()` function will be executed under the hood for any invocation of `{some RequestContext object}.mapHeaders`, the values for `correlationId.id` and `authorization` will be pulled from the object for which we're accessing the property `mapHeaders` on.\r\n\r\nUpdated the code a tiny bit as well, will update the suggestion above too:\r\n\r\n```kotlin\r\ninternal val RequestContext.mapHeaders: Map<String, String>\r\n    get() = mapOf(\r\n        ServiceHeaders.CONTENT_TYPE.headerName to APPLICATION_JSON,\r\n        ServiceHeaders.ACCEPT.headerName to APPLICATION_JSON,\r\n        ServiceHeaders.ONE_DATA_CORRELATION_ID.headerName to correlationId.id,\r\n        ServiceHeaders.ONE_DATA_CLIENT_ID.headerName to ServiceHeaders.ONE_DATA_CLIENT_ID_VALUE.headerName,\r\n        ServiceHeaders.AUTHORIZATION.headerName to authorization\r\n    )\r\n\r\n```",
            "Another option to solve for this would be accepting some optional parameter in the constructor (maybe a `@TestOnly` constructor?) which is a function of the form `(AppClientMetaData) -> JsonWebToken`, and invoking this to retrieve the `a2aJsonWebToken()`. In testing you could do something like ` { _ -> JsonWebToken(\"_mock_jwt\") }` to solve for this. Almost a psuedo-provider for this token"
        ]
    },
    {
        "14431": [
            "These fields can be null in the case of no messages present in the history unfortunately. We could technically make a special-case object down the road, but for this first pass I think it's best to keep it simple.",
            "> The title suggests that this is step one out of several other steps.\r\n> \r\n> What is the next step after this -- I.E., what's the complex attachment that you'll add?\r\n\r\nFlight, restaurant, and hotel product forms. Have those changes staged on another branch already."
        ]
    },
    {
        "14378": [
            "Do we need this + the suppress statement above? Not sure the intention here",
            "Sounds good, approved!"
        ]
    },
    {
        "14295": [
            "This is a critical part of being able to call the `getOrDefault` path when we're trying to deserialize. Relevant code below:\r\n\r\n```kotlin\r\n@Suppress(\"UNCHECKED_CAST\")\r\noverride fun fromJson(reader: JsonReader): T? = reader.readJsonValue().let {\r\n    if (it is Map<*, *>) {\r\n        runCatching {\r\n            typeAdapter.fromJsonValue(it)?.withBackingMap(it as Map<String, Any?>)\r\n        }.onFailure {\r\n            logger.warn(\"Error deserializing Unsure with type parameter: ${type.simpleName}\", it)\r\n        }.getOrDefault(\r\n            defaultConstructor.newInstance().withBackingMap(it as Map<String, Any?>)\r\n        )\r\n    } else {\r\n        throw JsonDataException(\"JSON value must be a Map.\")\r\n    }\r\n}\r\n```",
            "Annotations aren't inherited, I kind of liked this as it keeps it explicit for all child classes.",
            "We will log the throwable, which should contain the standard moshi details about the cause of the serialization failure, including the difference between the expected vs. actual data structure"
        ]
    },
    {
        "14200": [
            "These private constructors (and the supression statement above) are intentional, and meant to prevent invocation w/ some value other than the defined mask for the type. Please let me know if there are any concerns on this!",
            "Yeah this is handled in the PR stacked on top of it #14211"
        ]
    },
    {
        "14151": [
            "I didn't even know this `disable` function existed \ud83d\ude05 I tried to mimic how it was in other ST's, let me know if anything needs changing!",
            "The reason I used this name was I wanted to make it clear that this response body was specifically for mutation operations, as opposed to any contacts API response",
            "There is going to be quite a few changes coming in the next couple pull requests to solve for PII masking. I will be adding these system tests back in once this V3 endpoint is functional per the new requirements!"
        ]
    },
    {
        "14134": [
            "[Apache 2.0](https://github.com/google/libphonenumber/blob/master/LICENSE)"
        ]
    },
    {
        "13791": [
            "oops lol print debugging because I'm \"competent\" ",
            "building out some of these right now \ud83d\ude05 wanted to put this out in the wild to make sure I wasn't totally wasting my time before investing any more into it",
            "Glad to hear! I've added serialization equality tests, going to do the same for deserialization, but not sure what's best to do after that. Would definitely be open to any testing strategies if you have any off the top of your head",
            "There are some very difficult issues to solve in order to getting working in the way they're describing, as there's very non-trivial bytecode wrangling involved in the case of primitives. \r\n\r\nI don't believe the support was added to the moshi extensions libraries. It's not in the release notes, and I can't find any mentions of it. I think that issue may be stale and should be closed per [this issue on the main Moshi repo](https://github.com/square/moshi/issues/1170). I've [posted a comment](https://github.com/ZacSweers/MoshiX/issues/109#issuecomment-1158107022) asking about the status, and will update here accordingly.",
            "Another important consideration here is ease of refactor once support is added. This approach is pretty minimal overhead for the pseudo-inline classes themselves (which was a huge focus when I was trying to solve this). It should actually be refactorable via some `sed` command and regex for identifying that would logically look like:\r\n```\r\n{optional (data)} class {class name & constructor regex} : JsonInlineValue<{some type which matches the constructor}>\r\n```\r\nwhere `class name regex` covers the constraints for class name tokens & single-value constructors",
            "I'm not sure I understand, can you expand? Are you meaning to move each element of `inlineInstances` to separate tests?",
            "Great catch! Updating now!",
            "Updated with this!"
        ]
    },
    {
        "13675": [
            "Yeah it does unfortunately break the [contract](https://mobileone-docs.aexp.com/msl/messaging.html#messaging_v3_user_loyaltyprograms_get). @fsudeepk maybe we should consider contract changes to bring this in line for v3, given it's not being consumed yet?",
            "Nope, no good reason. I'll include this in the follow-up!"
        ]
    },
    {
        "13569": [
            "I gave a quick look, and from what I can tell we're not using `AddContactResponse-POST-v3-200-success.json` or `AddContactResponse-PUT-v3-200-success.json` anywhere after we removed this assertion. Can we delete this files as part of this pull request @fsudeepk?"
        ]
    },
    {
        "13412": [
            "Is this class's field names required to be named like this? At least to me, it's pretty unclear what this is actually representing, especially when compared to the fields in `About` and `About.LineItems.TextWithIcon`.\r\n\r\nAlso super nit:\r\nIf keeping like this, I personally like ordering parameters by nullability, then alphabetically. Not big at all though obviously haha.\r\n```suggestion\r\n            val item1: TextWithIcon,\r\n            val item2: TextWithIcon,\r\n            val item3: TextWithIcon?,\r\n            val nonZeroThresholdItem1: TextWithIcon?,\r\n```",
            "This definitely sense, though I would say we may want to evaluate this down the road as we seem to be seeing ourselves forced into these types of decisions as a result of some non-ideal patterns from the backend. There seems to be sufficiently large semantic differences to justify more separation, or changes to the structure to simplify consumers ability to use the BSC across markets. Not up to us unfortunately, and this is obviously an uninformed opinion from me, just how I perceive it based off of this brief interaction w/ this code."
        ]
    },
    {
        "13372": [
            "Super nit:\r\nI think this is a good use-case for receivers personally, just for readability's sake\r\n\r\n```suggestion\r\ninternal fun Outcome<AppClientException, CardDataBean>.isOpenCard(): Outcome<PayOverTimeV2Error.BackendError, Boolean> = with (this) {\r\n    mapError {\r\n        PayOverTimeV2Error.BackendError(it.errorMessage)\r\n    }.map {\r\n        it.isCompanyCard\r\n    }\r\n}\r\n```"
        ]
    },
    {
        "13370": [
            "Shouldn't this error actually be caught at deserialization time? \r\nDue to the fact that we have `Outcome<..., List<PlanV2>>`, we know that the presence of any null elements in the list will result in a nullability error. \r\nFunctionally the condition is just checking for a non-empty list, right? If so, I think we could simplify this code to something like:\r\n\r\n```suggestion\r\ninternal fun Outcome<PayOverTimeBSCError, List<PlanV2>>.toPlanV2(): Outcome<PayOverTimeV2Error, PlanV2> = with(this) {\r\n    mapError {\r\n        PayOverTimeV2Error.BackendError(it.toString())\r\n    }.map {\r\n        it.first()\r\n    }\r\n}\r\n```",
            "Definitely makes sense, I'll approve!"
        ]
    },
    {
        "13201": [
            "Polymorphic adapter sadly only work for `String -> String` mappings for some reason, for any non-string value attributes you can't use them. \r\n\r\nThese subclasses are reflected in the JSON we get back, we will get an array of \"users\", with effectively random ordering, and it will be composed of `Agent`'s and `Cardmember`'s in said array. More than that, this field here, `photo` is used by both, but has a different type between `Agent`s and `Cardmember`s, making it challenging to do what you're mentioning. It's definitely not ideal, but I think this is a pretty apt solution given the constraints",
            "Yeah good point, I've updated this to use `.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)`",
            "Yeah I've also updated this to include `DateTimeFormatter.ISO_LOCAL_DATE_TIME`",
            "Yes, as it's used as the key for the map, thus needs to be comparable",
            "Yeah I can do so in a follow-on PR",
            "Yup, specifically it's used to determine if we should deserialize to an `Agent` or a `Cardmember` instance of the `User` abstract class"
        ]
    },
    {
        "12998": [
            "Definitely agree, wasn't aware of that abstraction, done!",
            "Updated here as well!",
            "The reason I had avoided using the `ErrorResponse.Message` here was due to lack of seeing it being used in BSC client classes. I wasn't sure if there was a reason for this, but quite a bit of the metadata present in `ErrorResponse.Message` are specific to client-side actions so I (maybe prematurely) assumed that was intended to be used for client-side responses primarily.",
            "Sure, making this update now!",
            "This was due to some auto-formatting, odd, but I've resolved it now!",
            "Definitely, my bad",
            "Per the [MSL docs](https://github.aexp.com/pages/amex-eng/m1-msl//#/guidelines/backend-service-clients) we should do:\r\n\r\n> `BookingsClient` contains private functions to map client models to api models and vice versa.\r\n\r\n\r\nIn our case, `MeziCheckoutClient` is the BSC Client, and thus should contain these functions per my understanding. Let me know if reality doesn't line up with this documentation and something different is expected!",
            "Personally I don't think it makes sense to unify as a single error here if we're trying to be diligent about the \"best\" way of writing it. Simply due to them representing 2 distinct errors, unifying them here only serves as a detriment as I see it, but not obscenely rigid in that view, so if I'm missing something please let me know!",
            "There are no examples of non-2xx responses that I'm aware of, only empty and non-empty. I had assumed they won't send non-2xx, though if that's not the case if I can get a sample of one of these responses I can definitely add it!",
            "This was due to an intelliJ issue, when moving classes, I've fixed it now apologies",
            "Going to be closing this and breaking it up, per a discussion with @czschwar."
        ]
    },
    {
        "12790": [
            "Can we make this an interface instead? Mostly just to save some verbosity. Example below of what I'm thinking:\r\n```suggestion\r\ninternal sealed interface APRRateAndOfferData {\r\n    val offerType: APROfferType\r\n    val promoRate: Double\r\n\r\n    data class WithoutTooltip(\r\n        override val offerType: APROfferType,\r\n        override val promoRate: Double\r\n    ) : APRRateAndOfferData\r\n\r\n    data class WithTooltip(\r\n        override val offerType: APROfferType,\r\n        override val promoRate: Double,\r\n        val offerExpiration: ZonedDateTime,\r\n        val gotoRate: Double,\r\n    ) : APRRateAndOfferData\r\n\r\n```"
        ]
    },
    {
        "12569": [
            "> Are there any potential implications around logging sensitive data to worry about? I see the `toString` of the response, would hope BSC's aren't sending back something like a JWT or nastier, but we can't control that. Is debug enabled in prod?\r\n\r\nDisregard, I'm dumb, not doing any logging here obv"
        ]
    },
    {
        "12518": [
            "Yes, this is being done intentionally, this is calling the deserialization for the stricter version of MSL, what's been dubbed \"non-passthrough MSL\". The actual \"consumed\" value here will be the potential logs generated, as we are going to use these to drive analysis and implementation of this next version of conversation API's with the more strict serialization strategy.",
            "That's actually super clean, going to update this!\r\nThis also lets me get rid of the ugly moshi parameter nice",
            "> Is there something preventing this from being done here?\r\n\r\n\r\nMy bad habits \ud83d\ude05  This is certainly a better approach as well, overuse of inheritance is an issue I have, it's certainly a bad approach here seeing it w/ more fresh eyes.",
            "Ahh man, this is excellent, going to add this as well",
            "I keep finding myself needing to re-read this document as I have more ability to absorb the information contained within. Really like that there's a spec here, also a good reminder to go through the document and make sure I'm fully wringing everything from it \ud83d\ude04  I have added this as well though",
            "Yeah I have renamed this to `structuredDeserializationSidecar` in my commit. I don't love the name tbh, definitely open to suggestions if you have something cleaner in mind.",
            "Agreed on it, updated"
        ]
    },
    {
        "12423": [
            "What's the point of this `MeziCheckoutError` abstraction? Ideally if there's some data being sent back for the error, we'd capture that in an object, but I don't see the benefit of this abstraction.\r\n\r\n```suggestion\r\nobject MeziCheckoutError\r\n```"
        ]
    },
    {
        "12400": [
            "This is a super-set of all product messages to be clear",
            "Yeah definitely, wasn't aware of this, thanks!",
            "The readme is actually displaying Java syntax! Can tell by `class HoldemHand implements HandOfCards` which is invalid Kotlin. This requires a Java class for the first parameter here, and it rejects KClass's.",
            "Make sealed",
            "Doesn't need to be here\r\n\r\nUpdate: Generify FormAttachment<T>",
            "Going to be making this update in a follow-on when I do the sidecar portion",
            "Going to be making this update in a follow-on when I do the sidecar portion",
            "I actually have a fix for this on the subsequent pull request. It's a tad more involved in order to statically set it per-subclass, but it's present.",
            "Let me validate, I pulled live prod data, this value didn't come up in the set I pulled (150,000 message sample over a 6 month timeframe). ",
            "It's not a chat history difference funny enough, it's a backend Mezi difference, and we will observe it regardless of hitting V1 or V2 chat history. This is due to both endpoints serving us the document \"as is\" from Mezi. This is the root cause of some of the issues when it comes to various fields changing types randomly.\r\n\r\nThis attachment will be correct for both V1 & V2 though (I've validated) once a cardmember completes a product order and has paid via chat.",
            "In my opinion, as this is off the critical path currently, we shouldn't. \r\n\r\nThe reason is trying to trend towards a true contract, which means in the case of invalid enumerations we should indeed fail. Currently this will just log them (in the PR I have coming after this), but I think keeping those as failures is important, especially if the mobile client behavior is undefined",
            "Yeah I actually worked w/ @bfrane to ensure testability for the non-passthrough BSC yesterday. The mythical \"next PR\" which I have ready has some good tests for asserting on conversation history response parsing success or failure",
            "Not sure how I missed this, but you're definitely right on this one. Let me add it",
            "Oops lol yeah",
            "I guess a big part of my goal is removing the need to ask \"what happens to mobile clients when it gets to them\". \r\n\r\nI do have one idea that might make sense along this line of thinking, would be curious to know what you think. I do ultimately agree that any safe ways to avoid an SNR is where we need to work towards. \r\n\r\n**Proposal**\r\nWhat if instead of passing this message w/ `\"type\": UNKNOWN` to mobile clients, we defined a default type `MALFORMED` which is set as a default fallback adapter for all message deserialization (to act as a net to catch for both unknown types, and messages missing required fields etc.). We could then federate some error text to show instead, either at the MSL level or from AskAmex (I think AskAmex makes more sense as it would be market specific, and they drive similar configurations like the chat feature labels etc.). We could effectively iterate over the map of messages after deserializing and inject this error text when there is some `MALFORMED` type, replacing the `MALFORMED` message w/ some `text` type indicating we can't process it on Mobile. We would then of course log all of these instances for review and reconciliation. This would enable us to safely be ultimately quite resilient to failure as a result of malformed messages, without requiring exhaustive contracts, and hopefully having a large impact on the total times we display a \"System not responding\" screen to cardmembers. The other upside is we don't add a new element to the API contract for mobile clients, so they shouldn't require any change were this to be implemented."
        ]
    },
    {
        "12319": [
            "I can see `ChatContextDataType` and `SearchContext` aren't being used at all, are they planned for something? Seem like good candidates for cleaning up if not",
            "What is this sealed class `ChatIntentRequest` doing?\r\nIf it's required, can we make it an interface?",
            "Maybe a nit (sorry, it won't let me multiline this block for some reason, suggestion will be as code block below): \r\nCan we unnest these? When I use IntelliJ's `Go to Usage's` on `ChatContextData`, I am shown results for anything that imports `TransactionContext` or `SearchContext` as it must import `ChatContextData.<instantiation>`. This is contrary to how it works for everything else, and makes it feel unwieldy (in my opinion of course). \r\n\r\n```kotlin\r\nsealed interface ChatContextData {\r\n    val intent: String\r\n    val subTopic: String\r\n    val topic: String\r\n}\r\n\r\n\r\ndata class TransactionContext(\r\n    override val intent: String,\r\n    override val topic: String,\r\n    override val subTopic: String,\r\n    val data: TransactionContextData,\r\n) : ChatContextData {\r\n    data class TransactionContextData(\r\n        val accountToken: AccountToken,\r\n        val identifier: String,\r\n        @JsonProperty(\"statementEndDate\") @JsonSerialize(using = LocalDateSerializer::class)\r\n        val statementEndDate: LocalDate,\r\n        val status: ChatTransactionStatus\r\n    )\r\n}\r\n\r\ndata class SearchContext(\r\n    override val intent: String,\r\n    override val topic: String,\r\n    override val subTopic: String,\r\n    val text: SearchText\r\n) : ChatContextData\r\n```"
        ]
    },
    {
        "12102": [
            "These were tentatively decided against `enum`'ing originally, but had a few strategy shifts, and I think at this point it's likely a good idea. I'll add these and all the other enumerable fields as well",
            "Yeah this is a good point, updated this",
            "Okay for sure, updated as well",
            "This is actually a hard requirement, though it's pretty nasty that it exists. \r\n\r\nThis is the trace if we try and just use `jsonFileToObject` for PII Message and Travel Message:\r\n```\r\nCannot reflectively serialize sealed class com.americanexpress.mobileone.bsc.chat.conversation.AttachmentMessage. Please register an adapter.\r\njava.lang.IllegalArgumentException: Cannot reflectively serialize sealed class com.americanexpress.mobileone.bsc.chat.conversation.AttachmentMessage. Please register an adapter.\r\n\tat com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory.create(KotlinJsonAdapter.kt:224)\r\n\tat com.squareup.moshi.Moshi.adapter(Moshi.java:146)\r\n\tat com.squareup.moshi.Moshi.adapter(Moshi.java:106)\r\n\tat com.squareup.moshi.Moshi.adapter(Moshi.java:80)\r\n\tat com.americanexpress.mobileone.bsc.chat.conversation.ConversationApiMessageModelTest.pii message - valid(ConversationApiMessageModelTest.kt:46)\r\n        .....\r\n```\r\n\r\nThis is actually an artifact of the other portion of this work that's ongoing. This is for just single messages, but they come inside an even more complex response object, which is what this base serializer was originally for.\r\n\r\nI have cleaned it up now, but I'd like your input on it honestly. These serializers are very much so into the realm of magic realistically, but this bifurcation on `ConversationApiMessage` is required due to the underlying data. It's a huge headache, just wanted to give some context about why I'm doing it like this, it's not because I want to, moreso the data is so unruly this is the best I've come up with after 3-4 days working only on this",
            "Yeah good point, just flushed that out",
            "Forgot to response but this is exactly how I approached",
            "Heads up, I'm going to wait to model the data for the Travel forms until the follow-on PR I have ready. That PR has the complement to these forms, and it makes more sense to do the testing for those integrated w/ the product card responses. Just wanted to make it clear here @rgrondin so it didn't seem like I randomly left it out.\r\n",
            "I have a set of follow-up PR's on this same initiative so I will update them there @zsun3 "
        ]
    },
    {
        "12076": [
            "Is it out of scope to refactor this for this story? Especially `MaxLineLength` should be straightforward, don't know if we want to suppress here or try to clean up as we go. Not sure MSL's normal approach to these"
        ]
    },
    {
        "11939": [
            "Fixed this up!"
        ]
    },
    {
        "11908": [
            "This isn't using Moshi, it's using Jackson for the API response deserialization. [This is how we're handling deserialization](https://github.aexp.com/amex-eng/m1-msl/blob/23fbaa771dde6851c65d9e892ea1b7ccde919e8a/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/ConversationClient.kt#L79-L98), you can see in [this API](https://github.aexp.com/amex-eng/m1-msl/blob/23fbaa771dde6851c65d9e892ea1b7ccde919e8a/backend-service-clients/messaging-v2-service-client/chat-service-client/src/main/java/com/americanexpress/mobileone/bsc/chat/conversation/ConversationApi.kt#L41-L49) is returning the raw OkHttp3 ResponseBody directly. We're then passing that byte-array to the Jackson serializer. \r\n\r\nAs to \"why\" Jackson has to be used, I had a [Slack discussion](https://aexp-mobile-and-web.slack.com/archives/C4P2P9EPN/p1649352502105939) on this, I don't believe there's a way to achieve the same thing with Moshi. That's the only reason Jackson is being used.",
            "Yeah that is a better approach. I was doing two steps in one, creating the spec per the guidelines for new code and updating prior code, but I should (again :joy: ) split it up. I'll update this now!",
            "Great point, forgot about this part of our discussion. Updating it now as well!",
            "Yeah I agree, I think the client was getting overly dense in this case. I moved these out!",
            "I had a really insightful discussion again with @czschwar , I'm going to be closing this pull request, as there are 2 improvements that are going to be made to the underlying approach here. A similar pull request will be created with those changes, and I will be going through the above comments prior to raising that to address them. I will link back to this pull request from the new one. \r\n\r\nApologies on this, this requirement is complex and unorthodox, so I'm trying to keep the code fluid and evolve with it. I will work hard to make sure that the next pull request I open on this is truly ready for wider review, via a preemptive review with stakeholders."
        ]
    },
    {
        "11842": [
            "> > [Your build failed, here is why](http://mps-jenkins.us.aexp.com/job/M1-MSL/job/m1-m1-msl-msl-main-build-feature-M1-101110-ghe/1/execution/node/5/ws/features/peer-to-peer/build/reports/tests/test/index.html). [Rebuild](http://mps-jenkins.us.aexp.com/job/M1-MSL/job/m1-m1-msl-msl-main-build-feature-M1-101110-ghe/1/rebuild)\r\n> > Build scan: https://gradle.aexp.com/s/l5mie6fkrqpho\r\n> \r\n> Do we know why this test failed? I'm guessing it's a flaky test now that the p2p tests are running on a PER_CLASS lifecycle. I'm guessing there's some race condition. cc @bfrane\r\n\r\nYeah, I would guess a race condition as well, I didn't observe this test failure in my local. \r\n\r\n> Curious, what is the process for migrating a submodule to PER_CLASS? Any investigation into test classes, or are we setting the per_class default and seeing which tests fail?\r\n\r\nThe latter is basically my approach personally @mkarlsru. When things break I go in and try to resolve them, and maybe uplift a small bit to bullet-proof them if it's a quick-win."
        ]
    },
    {
        "11815": [
            "Yeah, I actually was going to do a bit of \"housecleaning\" for the data class duplication and some of the structure of the module, but wanted to focus this pull request on getting this functionality working as we had discussed. \r\n\r\nMy intention was to raise another pull request for restructuring this per this page detailing [BSC guidelines](https://github.aexp.com/pages/amex-eng/m1-msl//#/guidelines/backend-service-clients). If it makes sense to try and do this in one-shot I can do that for sure, just felt like this pull request was already pretty large",
            "Yeah I think this is a good suggestion",
            "Yeah, I was attempting to indicate this should be \"shared\" via placing it in \"commons\", but it seems like I may have caused more trouble than it's worth w/ that.",
            "See above ^"
        ]
    },
    {
        "11763": [
            "Nit:\r\nPersonally I prefer avoiding negations where possible, this one caught me up a little bit when I was reading it. I think the code could be more expressive if it was instead:\r\n```java\r\nreturn ChatResponseEligibility(status, chatEligibility, transactionType) ?\r\n    getTransactionChatProcessor(transactionId, billingCycleDateString, accountToken, itemType) : null;\r\n```",
            "Nit:\r\nI don't see why we need this variable `outcome`, we can instead just return directly. \r\nThis would look like:\r\n```java\r\nreturn chatIntentsProcessor\r\n    .getChatIntent(new TransactionChatIntent(transactionId, billingCycleDateString, accountToken, itemType))\r\n    .getOrNull();\r\n\r\n```"
        ]
    },
    {
        "11733": [
            "If we initialized the mock report in the mockMvc we would be able to avoid the `@BeforeEach`, not sure how much gain we get out of it. \r\n\r\nWe could do the below:\r\n```kotlin\r\nprivate val mockMvc = mockMvcBuilder(\r\n        PaymentsController(\r\n            confirmationProcessor = confirmationProcessor,\r\n            submitProcessor = submitProcessor,\r\n            inquiryProcessor = inquiryProcessor,\r\n            intentProcessor = intentProcessor,\r\n            methodsProcessor = methodsProcessor,\r\n            paymentsProcessor = paymentsProcessor,\r\n            reportProvider = reportProvider.withMockedReport(report)\r\n        )\r\n    ).build()\r\n\r\n    private val urlPath = \"/payment\"\r\n\r\n    @AfterEach\r\n    fun afterEach() {\r\n        clearMocks(report)\r\n        reportProvider.withMockedReport(report)\r\n    }\r\n```"
        ]
    },
    {
        "11730": [
            "This should be able to be removed without having any impact, right? Tests still pass locally without it for me",
            "Should be same as above",
            "Ditto",
            "Same here I think"
        ]
    },
    {
        "11689": [
            "Yeah actually agree that semantically that makes more sense when thinking of it as a lifecycle, I'll make these updates now",
            "~~I did this in the `@BeforeEach` because I actually faced issues w/ the first test execution, as there was logs from initialization.~~\r\n\r\nTurns out there's no issue after retrying this, will move this now!",
            "The `answers` param controls mock answers which are instantiated via the form:\r\n`every { <mock>.<method <parameters>> } returns <value>`\r\nThis prevents us from having to rebind these in each test\r\n\r\nI think I may need to look into how `unmockAll()` is working, because I would expect you would be right, but I'm observing something different. Without this `clearMocks` call I'm getting the failure w/ the below message:\r\n\r\n> Verification failed: call 1 of 1: PreferencesResponseBuilder(17).cardsPreferences(matcher<List>(), null())). 2 matching calls found, but needs at least 1 and at most 1 calls"
        ]
    },
    {
        "11688": [
            "Yeah this was missed by me, not sure why here, but I've updated!",
            "Added!",
            "Yup!",
            "Lots of statefullness baked into this test unfortunately"
        ]
    },
    {
        "11675": [
            "Yeah I'm going to be looking at removing this now. I had thought the conversion was out of scope, but happy to do it here. I'll update if it is too much effort, and create a ticket + the TODO",
            "Made a few more changes to support getting rid of `PER_METHOD` here, but tests are behaving as expected now without it",
            "Naive solution by me, wasn't aware of `clearMocks(Any)`, let me resolve these"
        ]
    },
    {
        "11673": [
            "Okay, let me try this and see if it will work in `PER_CLASS` mode, else will keep the `PER_METHOD` for the time being",
            "I was able to get this working just now luckily!",
            "Yeah this is my mistake, wasn't aware of this function!"
        ]
    },
    {
        "11661": [
            "Shoot my bad, let me fix this now, didn't even think about this.",
            "Shouldn't test builds fail due to this? I'm able to execute tests locally without issues. When I reformat I see it removing the unused imports, just curious if it's possible to have this catch at compile-time for tests. ",
            "Okay yeah this makes sense. Would there be any interest in a possible pre-commit hook that would run Detekt on any staged files? To avoid these situations making it to build runners. Would likely reduce what amounts to compute waste in the CICD pipeline."
        ]
    },
    {
        "11657": [
            "> You can use `Enable auto-merge` to save you a little bit of work for small PRs like this\r\n\r\nGood tip, I need to lookup how to do it from CLI. I don't even leave intelliJ in my current flow, adding this into it would be very neat."
        ]
    },
    {
        "11532": [
            "Good point, let me add this now"
        ]
    },
    {
        "11288": [
            "Randomization from prior pull-request is removed here, per the comment chain over there. Just wanted to be clear."
        ]
    },
    {
        "11265": [
            "This is intentional here, as it allows us to uniquely identify each test w/ minimal overhead. This enables us to make  assertions regarding individual tests' invocations of a method, as seen [here](https://github.aexp.com/amex-eng/m1-msl/blob/e189d75719c5169e0dd77805c9c9a62c547b18b6/backend-service-clients/lounge-finder-service-client/src/test/java/com/americanexpress/mobileone/bsc/loungefinder/bookings/BookingsClientImplTest.kt#L64) without needing to invoke `unmockAll` or loosen the assertions from the `verify(exactly = 1)` constraint. \r\n\r\nFigured I'd give a bit of background on my thinking just because I looked in the repository and didn't see UUID's being used like this (mostly used in `AppClientMetaData` initialization from what I can see)",
            "This randomization is added because this BSC treats `400` and `404` as special classes of errors. As such, any status codes in the set `{ statusCode >= 400 s.t. (statusCode != 400, statusCode != 404) }` should create \"true sad path\" behavior, which is why I randomized, to cover some possible edge-case (ie. if code is changed to catch `500` instead of `!400 && !404`)",
            "Good to know, agreed w/ the clarity, added!",
            "Yeah definitely makes sense, bad habit of avoiding newlines, but using them to demarcate this makes it much more readable. I've added this to all the tests.",
            "This is actually a habit I took out of \"Clean code\", but that's exactly the reason. Classes are nouns, methods verbs, etc., with the goal of creating an almost linguistic model of the process of writing code.",
            "Agreed for this, it's not clear here that we're generating a new UUID for each of these, which could cause pain down the line. Let me add this.",
            "Do you have an example of this usage? I see `OkHttpCall.NoContentResponseBody` but that is a package-private class with no way to reach from outside. I don't see how it's possible to get there, here's a [gist](https://github.aexp.com/gist/amichn/5328c6118e7050a45ccc6e2be1b738ee) for the code for `Response<T>` just for reference.",
            "Yeah I actually agree, I think the case where it's applicable is exactly what @czschwar said, running a bunch of these tests, but that's not what's happening here, so I think it's just going to add a potential pain point down the road. I'll remove this!",
            "I made a mistake here, I'm going to close this pull request, clean up the branch, and re-raise. Apologies"
        ]
    },
    {
        "11252": [
            "I do see the actual code ([link](https://github.aexp.com/amex-eng/m1-msl/tree/main/backend-service-clients/payments)) but I don't see any resource directories. ",
            "Done, didn't notice those, issue makes sense now"
        ]
    },
    {
        "11221": [
            "Shoot I wasn't aware it defaulted to `PER_METHOD`, thanks for this, making this change now!",
            "Update thesed, I refactored these out via IntelliJ and didn't even notice it didn't set them to private, thanks!",
            "It looks like the system tests were failing because of the missing `internal` modifier. Do you happen to know why? I have updated this to fix this, hoping it fixes the system test failures as well."
        ]
    },
    {
        "11205": [
            "Didn't even notice this, updated!",
            "Oops, didn't mean to commit it like this, this was me validating locally that I understood how the `Outcome<E, R>` was actually working. Updated this to reflect this change.",
            "Interesting, always a fan of that, I've updated these to reflect this change. \r\n\r\nSidenote, definitely would be really curious to know why that is, not sure if you can point me towards a good analysis of what's going on under the hood? I tried searching around but wasn't able to uncover anything. If not no big deal, mostly just curiosity if I'm honest, I like knowing how the \"tools of the trade\" actually work.",
            "Okay, this makes a lot of sense about how this functionality is actually being used. I updated it to reflect this, thanks for catching it!\r\n\r\nDo you know if there's any documentation I can reference regarding this `ramp-up` module? I see it's obviously a root-level module, so I'm assuming it's seeing pretty high usage, and I can kind of reverse-engineer what it's doing based on the code, but I'd rather read something I know is right instead of hoping my Kotlin skills are sharp enough after a week to give me a complete understanding \ud83d\ude05 ",
            "Great point, fixed this as well!",
            "\ud83e\udd26  thanks lol @giyer7 , might have to give this whole documentation a weekly once-over for the first month or so, the lens with which I am able to read it through is changing pretty quickly as I onboard. Thanks a ton!",
            "I updated this, I agree wholeheartedly!"
        ]
    },
    {
        "11136": [
            "Dang Kotlin is super neat, wasn't aware of this yet, thanks!",
            "I think your way is definitely more expressive and transparent, will update!",
            "Yeah I actually was unsure about that when I was looking through the source for `Outcome`, this makes it super clear. \r\nI just had a discussion w/ @czschwar on this as well, I (hopefully) have a much better understanding of the \"what and why\". Thanks for prompting that!",
            "So if I'm being totally honest, I don't really know. I followed really closely the patterns in the reference implementation, which is where I saw this being done. \r\n\r\nI figured it was for readability, and because as I understand it (definitely not 100% on this), but it looks like the type of this first element is getting functionally ignored in the reference implementation. Definitely want to understand more about why the reference implementation is taking this approach, when it's appropriate, and what we gain from doing this.\r\n\r\nHere are the files I drew from for this, just for reference:\r\n- [ReferenceImplementationApi](https://github.aexp.com/amex-eng/m1-msl/blob/b50408e078751985890b70d3ea01711157256cf2/backend-service-clients/reference-implementation/src/main/java/com/americanexpress/mobileone/bsc/referenceimplementation/ReferenceImplementationApi.kt#L26)\r\n- [ReferenceImplementationClient](https://github.aexp.com/amex-eng/m1-msl/blob/8aa09f953a60af16e9939e0f469aaba444a2bda9/backend-service-clients/reference-implementation/src/main/java/com/americanexpress/mobileone/bsc/referenceimplementation/ReferenceImplementationClient.kt#L36)\r\n- [AccountsApiModel](https://github.aexp.com/amex-eng/m1-msl/blob/801535d6ce90e8144558f3edab6e54f9dbe316f3/backend-service-clients/reference-implementation/src/main/java/com/americanexpress/mobileone/bsc/referenceimplementation/accounts/AccountsApiModel.kt#L14)\r\n- [AccountsClientModel](https://github.aexp.com/amex-eng/m1-msl/blob/b50408e078751985890b70d3ea01711157256cf2/backend-service-clients/reference-implementation/src/main/java/com/americanexpress/mobileone/bsc/referenceimplementation/accounts/AccountsClientModel.kt#L16)",
            "Yeah I agree with you here, I think that's going to be one of the things I need to focus on as I learn the language and MSL more. Kotlin has a very high potential for \"magic\", which while it can be handy, can definitely obfuscate code and make it unapproachable. \r\nI'm making this change now as well!",
            "I was actually curious about placement, because I was definitely uncertain that I should put this in what seemed like a pure data-class file. Forgot to get input on this, glad you caught it, and this definitely makes perfect sense to me that we should move this to some `*Normalizer.kt` given it's certainly performing some normalization action.",
            "I updated per this comment as well, I had a great discussion on Friday regarding the use of these extension functions, and the concern of seeing them as \"the golden hammer\" after coming from java. Trying to decipher when it's appropriate to use them, and when we would be better served to use a function that consumes the object. ",
            "I updated w/ this recommendation @czschwar , with the `inline class` approach as we are indeed using Moshi for the adapter",
            "@czschwar I did try to do `inline class ...` here, but I got a warning from IntelliJ indicating that `inline class` was deprecated, and to instead use this annotation. Not sure if this approach is still valid, figured I'd call it out though.",
            "I actually did this because I only uplifted the `GET` operation on this endpoint, but there are PUT and POST operations as well. The [API class](https://github.aexp.com/amex-eng/m1-msl/blob/4fe377cc373020da188829cc1a9fabc3a200d965/backend-service-clients/mezi-client/version2/src/main/java/com/americanexpress/mobileone/bsc/mezi/contact/MeziContactApi.kt#L32-L52) for the POST contract is returning a `Call<...>` object, which the [test is mocking](https://github.aexp.com/amex-eng/m1-msl/blob/d58335fc010d456d90c511c3d447364e37d56281/backend-service-clients/mezi-client/version2/src/test/java/com/americanexpress/mobileone/bsc/mezi/contact/MeziContactClientImplTest.kt#L124-L147). \r\n\r\nI wanted to understand how this actual `MockWebServer` was working, because I think it's a much more elegant solution and obviously gets away from the explicit mocks. I didn't try to use it with the `Call<S>` operations, I could see while it looks like `ApiResultResponse<E, S>` is a wrapper over the retrofit `Call<S>`, it looks like it's doing quite a bit, and given I didn't change those methods I figured best-practice would be to not make changes in the tests, especially given they were still passing without issues.\r\n\r\nThat was at least my thinking, I definitely agree this isn't a super elegant solution though. Normally I'd have take the approach you described, as I definitely agree with you that recreating this in each test is overzealous in the pursuit of decoupling.",
            "The reason I wasn't using the [Outcome<ErrorResponse, T>.handleResult()](https://github.aexp.com/amex-eng/m1-msl/blob/main/msl-common/src/main/java/com/americanexpress/mobileone/response/ResponseHandler.kt#L14) function was that it would have changed the contract. \r\n\r\nSpecifically, the field `userInformation` is defined here at depth-0 in the response body, whereas if we used this `handleResult` approach, we would nest it under `data.userInformation`. Definitely an inconsistency here, but I wasn't sure of a way around it without breaking the contract. \r\n\r\nWhat I've done is mimicked the type-checking in `ResponseHandler.handleError` to have some sort of middle ground. Definitely not ideal, but constrained as this code looks like it came before we standardized to this approach. ",
            "Yeah I actually totally agree, this was due to a misunderstanding I had which caused me confusion when I was going through and converting some of the tests. It's clear when I look at this now, I've restored `MeziContactClientModule` to its' original state.",
            "Yeah this was me chasing a red-herring, same as other comment. The design definitely makes sense here to maintain.",
            "This request timeout wasn't there originally, I am going to remove it to not introduce that requirement here.\r\n\r\nSo I definitely agree w/ this, I'm a zealot against string-literals, the only reason I did it like this was to retain strict parity with the reference implementation ([here](https://github.aexp.com/amex-eng/m1-msl/blob/b50408e078751985890b70d3ea01711157256cf2/backend-service-clients/reference-implementation/src/main/java/com/americanexpress/mobileone/bsc/referenceimplementation/ReferenceImplementationApi.kt#L22)). It's the same reason I removed the `PARAM_` prefix from the constants for the parameter keys. I likely read a bit too much into this honestly, I've updated it now so it's pulled out to a constant. I agree it reads better that way. ",
            "200% agree with you, let me add this real quick!",
            "I avoided any change to this contract with this pull request, just to be clear. Are you saying I should make the change in the RAML (as well as the code) such that we adhere to the new standards?",
            "> I like it when people do cleanup and improvements, thanks for this work!\r\n> \r\n> I recommend scoping your PRs to smaller chunks, maybe grouped by focal points or areas of refactor, so that reviewing can be easier and the iteration time can be reduced.\r\n\r\nI definitely intend to do that in the future, this grew a little bit more than I wanted if I'm honest. A big transition from my prior team towards these much more atomic PR's, but a great habit to get into. I'll definitely keep it in mind when I'm looking to raise another, the lifecycle on this PR was too long as well. The optimist in me says it just gives me lots of easy-to-measure metrics to evaluate my progress \ud83d\ude05 "
        ]
    }
]